\documentclass[a4paper, 12pt, oneside]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=3cm, bindingoffset=1cm]{geometry}
\linespread{1.5}
\usepackage{float}
\usepackage{csquotes}
\usepackage{subfig}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{alphabeta}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{hyperref}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{minted}
\usepackage[htt]{hyphenat}
\usepackage{pgfplots}
\usepackage{wrapfig}
\usepackage{bm}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage[bottom]{footmisc}


\usepackage{mathtools, nccmath}
\DeclarePairedDelimiter{\nint}\lfloor\rceil % https://tex.stackexchange.com/questions/433101/rounding-to-nearest-integer-symbol-in-latex. Grazie!

\usepackage[
    backend=biber,
    sorting=none
]{biblatex}
\addbibresource{bibliography.bib}


\setlength{\parindent}{1cm}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{\textbf{\leftmark}}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
\renewcommand{\contentsname}{Indice}
\usepackage{caption}
\captionsetup[figure]{labelformat=empty}

\usepackage[Conny]{fncychap}

\theoremstyle{definition}
\newtheorem{definition}{Definizione}

\begin{document}
\begin{titlepage}
    \begin{center}
        \LARGE{\uppercase{Università degli Studi di Salerno}}\\
        \vspace{5mm}
    	\uppercase{\normalsize Dipartimento di Informatica }\\
    \end{center}
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.35\textwidth]{logo_unisa}
    \end{figure}
    
    \begin{center}
        \normalsize{\textbf{Corso di Laurea Magistrale in Informatica}}\\
    	\vspace{10mm}
    	\LARGE{\textbf{Securing \textsc{MAVLink} protocol: a Post Quantum cryptography-based approach}}\\
    	\vspace{3mm}
        \large{\uppercase{Anno Accademico 2022/2023}}
    \end{center}

    \vspace{50mm}
    \noindent
    \begin{minipage}[t]{0.4\textwidth}
    	\textsc{Relatore}\\Prof. \textbf{Arcangelo Castiglione}\\
        \small Università degli Studi di Salerno
    	\vspace{12mm}\\
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.4\textwidth}\raggedleft
    	\textsc{Candidato} \\\textbf{Hermann Senatore}\\\small Matricola: \textbf{0522501273}
    \end{minipage}
\end{titlepage}
\newpage

\begin{titlepage}
\nonumber
\null \vspace {\stretch{1}}
    \begin{flushright}
        \textit{We're flying high \\
        We're watching the world pass us by\\
        Never want to come down\\
        Never want to put my feet back down on the ground} \\
        \textbf{(Depeche Mode)}
    \end{flushright}
\end{titlepage}
    
\newpage
\tableofcontents
\newpage

\begin{abstract}
    L'evoluzione tecnologica a cui si sta assistendo negli ultimi anni sta rivoluzionando pesantemente (tra le altre cose) il mondo dell'aviazione, merito anche (e soprattutto) dei cosiddetti \textbf{UAV} (unmanned aerial vehicle), che comunemente vengono definiti \textbf{droni}, impiegati sia in contesto "civile" che in contesto militare. 
    
    La potenziale delicatezza delle missioni che questi veicoli si trovano ad affrontare suggerisce dunque la necessità di definire dei requisiti di sicurezza che ne permettano un impiego più agevole. L'innovazione tecnologica porta però a nuove sfide anche nel campo della sicurezza. 
    
    In particolare, i recenti progressi nel campo del \textbf{quantum computing} aprono nuove sfide nel contesto della crittografia, rendendo quindi necessario sviluppare nuove tecniche resistenti ad attacchi veicolati mediante computer quantistici. In questo lavoro viene presentato un \textbf{proof of concept} di un'architettura basata sul protocollo \textsc{MAVLink} che permetta una comunicazione sicura tra un drone e la sua \textbf{Ground Control Station} e, ad un livello più alto, la definizione della chiave di cifratura utilizzata mediante il \textbf{Key Encapsulation Mechanism} Kyber, selezionato dal \textbf{NIST} come lo standard per quanto riguarda gli algoritmi di incapsulamento \textbf{quantum resistant}.
\end{abstract}
\newpage

\section{Introduzione}

\subsection{Scopi e struttura della tesi}
Il presente lavoro si concentra, come tra l'altro già accennato in precedenza nell'abstract, sull'analisi del proof of concept di un'architettura basata sul protocollo \textsc{MAVLink} che permetta lo scambio di chiavi e la comunicazione cifrata tra un UAV e la sua centrale di comando a terra utilizzando il KEM quantum-resistant Kyber e l'algoritmo AES in modo tale da proteggere lo scambio di messaggi tra i due \textit{endpoint} della comunicazione.

In particolare:

\begin{itemize}
    \item Questo capitolo funge da introduzione al lavoro svolto durante l'attività di Tesi, ne illustra la struttura e ne chiarisce le motivazioni ed il contesto in cui è calato;
    \item il \textbf{Capitolo 2} fornisce una panoramica sulle principali piattaforme software considerate nel presente lavoro;
    \item il \textbf{Capitolo 3} fornisce una panoramica sul protocollo \textbf{\textsc{MAVLink}};
    \item il \textbf{Capitolo 4} discute alcune problematiche di sicurezza che affliggono il protocollo \textsc{MAVLink} e discute alcuni approcci a questo problema presnti in letteratura;
    \item il \textbf{Capitolo 5} fornisce un'introduzione all'impatto dell'avvento dei \textbf{Computer Quantistici} nel campo della crittografia e al concetto di \textbf{Post-Quantum Cryptography} (PQC). Si procederà quindi ad una panoramica dell'algoritmo \textbf{Kyber};
    \item il \textbf{Capitolo 6} illustra in dettaglio le \textbf{modifiche} effettuate alle piattaforme software considerate nel presente lavoro ed al protocollo \textsc{MAVLink} stesso;
    \item il \textbf{Capitolo 7} fornisce le \textbf{conclusioni} al presente lavoro e illustra alcuni possibili \textbf{sviluppi futuri}.
\end{itemize}

\newpage


\subsection{UAV, APR o Droni: nomenclatura}
Nell'ultimo decennio, l'importante evoluzione tecnologica nel contesto dell'aviazione ha permesso la progettazione e la concreta realizzazione di veicoli in grado di volare e compiere missioni anche \textbf{senza la presenza di un pilota umano} sempre più versatili, efficaci e precisi. Questa tipologia di veicoli viene definita, a seconda del contesto linguistico in cui ci si trova, \textbf{UAV} (\textit{unmanned aerial vehicle}), \textbf{APR} (\textit{aeromobile a pilotaggio remoto}) o, più comunemente, \textbf{Drone}. Tutti questi acronimi sono, quindi, equivalenti tra di loro. 

La presenza di un essere umano continua tuttavia ad essere fondamentale in quanto il pilotaggio di questi dispositivi viene effettuato mentre una struttura di controllo "a terra", che prende il nome di \textbf{Ground Control Station} (da qui in poi \textit{GCS}). Tipicamente, una GCS può essere rappresentata da un qualsiasi apparato in grado di comunicare in qualche modo con l'UAV, quindi anche un comune Personal Computer su cui viene posto in esecuzione un software specifico.

\subsection{Cenni storici}
Il concetto di aeromobile senza pilota in sé non è sorprendentemente prerogativa degli ultimi anni e delle conseguenze che l'avvento delle tecnologie informatiche si porta dietro. Risale infatti agli Anni '40 del XIX secolo il primo (rudimentale!) impiego di "dispositivi" volanti senza pilota in campo militare. 

Per fronteggiare i moti rivoluzionari, peraltro diffusi anche in tutta Europa nel 1848, nella città di Venezia (che avevano portato alla creazione della cosiddetta Repubblica di San Marco), l'esercito austriaco lanciò dei \textbf{palloni} a cui era stato fissato dell'\textbf{esplosivo} dalla nave "Vulcano". 

Questo primo esperimento portò a risultati "misti": alcuni di questi dispositivi riuscirono effettivamente a colpire la città, altri furono invece deviati dal vento.

Per tutto il XIX secolo, lo sviluppo di questo tipo di dispositivi rimase prerogativa militare, con gli americani e gli inglesi che si occuparono dello sviluppo dei primi aeromobili comandati tramite radiofrequenza. Questi ultimi, nel 1917, testarono con successo un velivolo chiamato \textbf{Aerial Target}, mentre gli americani misero a punto il cosiddetto \textbf{Kettering Bug} \cite{drones-history}.

Nessuno di questi due prototipi venne tuttavia impiegato nella \textbf{prima guerra mondiale}.

Come già accennato in precedenza, con il passare del tempo e con il sempre più spinto progresso tecnologico i droni e, più in generale i veicoli a guida remota, hanno trovato un fertile campo di applicazione anche nell'ambito \textbf{civile}. Ad esempio, nel 2022 è stato proposto uno studio in cui è stato utilizzato un insieme di veicoli senza pilota per monitorare il processo di realizzazione di un \textbf{ponte} \cite{rs14081858}.
Si è assistito, riassumendo, ad una "democratizzazione" dell'uso dei droni negli ambiti più disparati.

\subsection{Sviluppi recenti}
Proprio questa diffusione più capillare dell'uso di suddetti veicoli a guida remota ha portato ad una più grande attenzione nello sviluppo di tecnologie software specifiche a questo ambito. 

A partire dagli anni 10 del XXI secolo sono stati concepiti diversi progetti software \textbf{open source} che forniscono piattaforme integrate compatibili con diversi tipi di apparati sia lato UAV che lato GCS. 

Parimenti, è stato necessario definire uno \textit{standard} per quanto riguarda l'ambito dei protocolli di comunicazione tra il drone e la sua \textit{GCS}, che è rappresentato sicuramente dal protocollo \textbf{\textsc{MAVLink}} e dalle sue successive evoluzioni. 

Una panoramica più approfondita sul protocollo \textsc{MAVLink} verrà in ogni caso affrontata nelle prossime sezioni in cui verranno illustrate le piattaforme software utilizzate nell'ambito del presente lavoro.

\newpage

\section{Piattaforme software per UAV e GCS}
Il presente capitolo fornisce una panoramica delle principali tecnologie utilizzate in ambito \textbf{civile} ed \textbf{amatoriale} nel contesto dei velivoli a pilotaggio remoto. In particolare viene riservata particolare attenzione ai seguenti due progetti \textbf{open source}:

\begin{itemize}
    \item \textbf{ArduPilot}: una piattaforma integrata scritta in \textbf{C++} utilizzabile su diverse tipologie di veicoli non necessariamente adatti al volo;
    \item \textbf{QGroundControl}: una \textbf{Ground Control Station} open source scritta in C++, che utilizza il framework \textbf{Qt} e che permette una più stretta interazione con la piattaforma ArduPilot.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/ardupilot_logo.png}
    \caption{Il logo di ArduPilot}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/QGC_RGB_Logo_Horizontal_Positive_PREFERRED.png}
    \caption{Il logo di QGroundControl}
\end{figure}

Viene quindi svolta una panoramica sul protocollo di comunicazione \textbf{\textsc{MAVLink}} che permette l'interazione tra queste due componenti.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/logo_mavlink_small.png}
    \caption{Il logo del protocollo \textsc{MAVLink}}
\end{figure}

\newpage

\subsection{ArduPilot}

ArduPilot, come accennato, è una suite software universale che permette il controllo di diversi veicoli \textbf{non necessariamente volanti} \cite{ardupilot} la cui nascita risale al 2007.  L'idea di una suite software quale ArduPilot è stata formalizzata presso la piattaforma \textbf{DIYDrones.com}, community dedicata agli UAV fondata da \textbf{Chris Anderson} e che si definisce quindi "The Birthplace of ArduPilot"\cite{diy-drones}.

Nel 2009 venne prodotta la prima \textbf{board} che utilizzava questa piattaforma e nel novembre dello stesso anno il codice sorgente del progetto venne reso pubblico (ed è attualmente disponibile su GitHub all'url \url{https://github.com/ArduPilot/ardupilot})\cite{ardupilot-history}.

Correntemente, il progetto permette l'utilizzo su diverse tipologie di dispositivi, mediante delle versioni del firmware leggermente diverse tra di loro. In particolare, ArduPilot supporta dispositivi del tipo:

\begin{itemize}
    \item \textbf{Copter}: probabilmente quello più diffuso tra tutti e che tipicamente è composto da una board a cui sono associate diverse \textbf{eliche}. Il progetto di riferimento si chiama \textbf{ArduCopter}\cite{arducopter};
    \item \textbf{Plane}: un tipo di dispositivo ad \textbf{ala fissa}, tipicamente un \textbf{aereo radiocomandato}. Il progetto di riferimento si chiama \textbf{ArduPlane}\cite{arduplane};
    \item \textbf{Rover}: un tipo di dispositivo che non può spiccare il volo ma dotato di ruote e che di conseguenza viene utilizzato per missioni "a terra". Il progetto di riferimento si chiama semplicemente \textbf{Rover}\cite{rover};
    \item \textbf{Sub}: un tipo di dispositivo subacqueo, appartenente alla categoria degli \textbf{Autonomous Underwater Vehicles} (\textit{AUV}). Il progetto di riferimento si chiama \textbf{ArduSub}\cite{ardusub};
\end{itemize}

\begin{figure}[H]
    \centering
    \subfloat[\centering Copter]{{\includegraphics[width=0.4\textwidth]{images/copter.jpg} }}
    \qquad
    \subfloat[\centering Plane]{{\includegraphics[width=0.4\textwidth]{images/plane.jpg} }}
\end{figure}
\begin{figure}[H]
    \centering
    \subfloat[\centering Rover]{{\includegraphics[width=0.4\textwidth]{images/rover.jpeg} }}
    \qquad
    \subfloat[\centering Sub]{{\includegraphics[width=0.4\textwidth]{images/sub.jpeg} }}
\end{figure}

Il progetto fornisce anche del codice specifico per apparati "complementari" ai dispositivi qui sopra descritti. In particolare:

\begin{itemize}
    \item \textbf{AntennaTracker}: che permette di governare apparati che si occupano di ricevere il segnale proveniente dai dispositivi controllati da remoto\cite{antennatracker};
    \item \textbf{Blimp}: un particolare tipo di "pallone" aerostatico dotato di motore\cite{blimp}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/antenna.jpg}
    \caption{AntennaTracker}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/blimp.png}
    \caption{Blimp}
\end{figure}

\subsubsection{SITL - Software in the Loop}
Il progetto ArduPilot mette inoltre a disposizione anche un \textbf{emulatore} che permette il testing di tutte queste varianti della piattaforma \textbf{senza possedere l'hardware adatto} \cite{sitl} e quindi procedere al \textbf{flashing} del firmware. 

Tale emulatore prende il nome di \textbf{SITL} (\textit{Software In The Loop}) e risulta quindi molto utile quando è necessario svolgere attività di testing preliminari per valutare il comportamento del firmware in use case differenti. 

Tra l'altro, proprio l'utilizzo di SITL ha permesso la realizzazione di questo lavoro in totale autonomia da hardware specifico. 

Maggiori informazioni su SITL e sul suo utilizzo saranno proposte in una successiva sottosezione dove verranno presentati ulteriori dettagli sull'architettura software del progetto ArduPilot.

\subsubsection{ArduPilot: architettura software}
Come menzionato in precedenza, il progetto ArduPilot utilizza il linguaggio di programmazione \textbf{C++}, che è uno di quelli più utilizzati per la programmazione di sistemi embedded in generale poiché \textbf{gira direttamente sull'hardware} senza bisogno di macchine virtuali di sorta (al contrario di Java o di linguaggi interpretati), permettendo di ottenere prestazioni migliori in un contesto in cui proprio le prestazioni rappresentano un requisito fondamentale.

Dal punto di vista della configurazione del progetto, la scelta degli sviluppatori di ArduPilot è ricaduta sul framework \textbf{waf}. Tale framework, scritto in Python, offre un ambiente di build modulare e per quanto possibile agnostico rispetto ai linguaggi di programmazione utilizzati nel progetto col quale lo si vuole usare.

In breve, la documentazione di waf \cite{waf} suggerisce che:

\begin{itemize}
    \item Per utilizzare il framework è necessaria unicamente un'installazione di \textbf{Python};
    \item Waf non definisce un nuovo "linguaggio" (come avviene nel meccanismo dei \textbf{Makefile}) ma si compone di moduli scritti in Python, che permette quindi una maggiore riusabilità delle componenti;
    \item I "target" sono definiti come oggetti python dichiarati in maniera separata dai comandi (definiti invece come funzioni in un file chiamato \texttt{wscript}).
\end{itemize}

\subsubsection{Compilare ArduPilot}

Il progetto GitHub della piattaforma ArduPilot contiene il codice sorgente specifico di tutte le tipologie di veicolo, organizzato in directory separate\cite{ardupilot-github}. In particolare:

\begin{itemize}
    \item \texttt{ArduCopter/} contiene il codice sorgente specifico per i veicoli di tipo \textbf{Copter};
    \item \texttt{ArduPlane/} contiene il codice sorgente specifico per i veicoli di tipo \textbf{Plane};
    \item \texttt{ArduSub/} contiene il codice sorgente specifico per i veicoli di tipo \textbf{Sub};
    \item \texttt{Rover/} contiene il codice sorgente specifico per i veicoli di tipo \textbf{Rover};
    \item \texttt{AntennaTracker/} contiene il codice sorgente specifico per i dispositivi che comandano \textbf{antenne di invio/ricezione};
    \item \texttt{Blimp/} contiene il codice sorgente specifico per i veicoli di tipo \textbf{Blimp}, come descritti in precedenza;
\end{itemize}

Inoltre, mediante il comando \texttt{configure} ed il parametro \texttt{-{}-board=} è possibile personalizzare ulteriormente la compilazione del firmware adattandolo ad un \textit{tipo di board} specifico o istruendo il sistema a prepararsi ad essere utilizzato mediante \textbf{SITL}\cite{how-to-build-ardupilot}. Quest'ultimo scenario è quello utilizzato nel presente lavoro e si ottiene eseguendo il comando:

\begin{center}
    \texttt{./waf configure -{}-board=sitl}
\end{center}

e, per generare il firmware specifico per un determinato tipo di veicolo (in questo caso quello di elezione è \textbf{Copter}), è necessario eseguire il seguente comando:

\begin{center}
    \texttt{./waf copter}
\end{center}

Per avviare l'emulatore \textbf{SITL} configurato in precedenza è necessario recarsi nella directory del veicolo per cui si è scelto di compilare il firmware (specificato nel comando precedente) (in questo caso, \texttt{ArduCopter/})

\begin{center}
    \texttt{cd ArduCopter/}
\end{center}

e finalmente eseguire l'emulatore mediante il comando

\begin{center}
    \texttt{sim\_vehicle.py}
\end{center}

Nota: il file appena descritto è presente nel percorso \texttt{/Tools/autotest/} ma non è necessario specificare il suo path assoluto perché durante l'installazione dei prerequisiti di ArduPilot, quest'ultimo viene aggiunto in maniera system-wide alla variabile d'ambiente \texttt{PATH}.

A questo punto, il veicolo "virtuale" è pronto ad accettare connessioni da una GCS. In particolare, viene aperta la porta \textbf{5760} sull'interfaccia di \textbf{loopback} locale.

È anche possibile modificare il numero di porta utilizzato e l'interfaccia su cui mettersi in ascolto.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/sitl.jpg}
    \caption{SITL in esecuzione}
\end{figure}



\subsubsection{ArduPilot: integrazione con il protocollo \textsc{MAVLink}}
Il progetto ArduPilot usa il protocollo \textsc{MAVLink} per comunicare con le Ground Control Stations. Il codice sorgente che implementa le primitive e le funzioni di supporto per la comunicazione non è però già disponibile all'atto della clonazione del progetto da GitHub. Al contrario, è stato configurato il tool \texttt{mavgen} come \textit{submodule} all'interno della repository. Tale tool, richiamato dal sistema di building \texttt{waf} all'atto della compilazione del codice per un determinato veicolo, permette di generare \textit{dinamicamente} tutto il codice di basso livello necessario per le operazioni di comunicazione verso l'esterno\cite{mavgen}. Più nello specifico, viene generata una libreria \textit{headers-only} in linguaggio \textbf{C}, che tuttavia risulta perfettamente interoperabile con il resto del software scritto invece, come già menzionato, in C++. Maggiori dettagli su questo tool saranno forniti durante la panoramica che verrà svolta riguardo il protocollo \textsc{MAVLink}.

\newpage

\subsection{QGroundControl}

\subsubsection{Panoramica sulle principali GCS disponibili}

Come menzionato in precedenza, un UAV per essere totalmente operativo ha bisogno di una componente \textbf{"a terra"} che lo governi: questa componente prende appunto il nome di \textbf{Ground Control Station} (GCS) e si occupa di gestire la connessione con l'UAV mediante il protocollo più adatto e di controllarlo mediante messaggi tipicamente aderenti alle specifiche \textbf{\textsc{MAVLink}} (maggiori informazioni sono fornite nella sottosezione dedicata). È quindi pacifico affermare che il software in questione risulti essere nella maggior parte dei casi \textbf{molto complesso} dal punto di vista dei requisiti a cui deve rispondere e da quello dell'architettura software.

Attualmente, sono disponibili pubblicamente diverse Ground Control Station più o meno sofisticate. Tra queste si annoverano:

\begin{itemize}
    \item \textbf{MAVProxy} \cite{mavproxy}: una (non necessariamente) command-line-based GCS che possiede tutti gli strumenti necessari a comandare un UAV risultando al contempo utilizzabile su sistemi con a disposizione relativamente poche risorse. Di default, è quella che si avvia al momento dell'esecuzione di \textbf{SITL} a meno che non venga passato il parametro \texttt{-{}-no-mavproxy} allo script \texttt{sim\_vehicle.py} (come accennato in precedenza);
    \item \textbf{Mission Planner} \cite{mission-planner}, sviluppato da \textbf{Michael Orbone} e che permette di gestire diversi aspetti di una missione di un UAV: dalla configurazione dei waypoints (in termini di coordinate GPS) ai comandi da far eseguire all'UAV durante lo svolgimento della missione;
    \item \textbf{APM Planner 2}: sostanzialmente \textbf{un'evoluzione} dello strumento Mission Planner, creato dal team di sviluppo di \textbf{ArduPilot} e che permette di gestire sia dispositivi basati su ArduPilot stesso che basati sulla piattaforma \textbf{PX4};
    \item \textbf{QGroundControl} \cite{qgroundcontrol}: probabilmente la GCS più funzionale tra quelle appena descritte. È stata sviluppata dal team che si occupa del protocollo \textbf{\textsc{MAVLink}} e che permette di interfacciarsi con qualsiasi dispositivo che supporti i messaggi \textsc{MAVLink}. Tale piattaforma è stata utilizzata per realizzare parte del lavoro di tesi qui presentato. 
\end{itemize}

\subsubsection{Architettura software di QGroundControl}

Come accennato, QGroundControl è un software molto complesso e che fornisce una moltitudine di funzionalità, che vanno dalla pianificazione delle missioni al monitoraggio dei messaggi \textsc{MAVLink} tramite un \textbf{inspector} \textit{ad-hoc}, per citarne alcune.

Il progetto è stato sviluppato dall'organizzazione che si occupa di \textsc{MAVLink} e, più in generale, del \textbf{MAV-SDK}: la \textbf{DroneCode Foundation}, che ha come mission quella di "creare uno standard nell'industria dei droni mediante progetti open-source"\cite{dronecode}. 

È scritto interamente in \textbf{C++}, eccetto per lo stack di comunicazione \textsc{MAVLink} in uso, mediante l'ausilio del framework \textbf{Qt} ed il suo codice sorgente è disponibile su GitHub \cite{qgc-github}.

Al contrario delle altre GCS, QGroundControl \textbf{supporta anche la compilazione per la piattaforma Android}\cite{qgc-github-android}, il che di conseguenza permette l'utilizzo del software su dispositivi portatili e rendendo il progetto completamente \textbf{cross-platform}.

In ogni caso, il \textit{core} della piattaforma è presente all'interno della directory \texttt{src/} nella root della repo GitHub. Qui sono presenti tutti i moduli che permettono, tra le altre cose, la gestione dei veicoli connessi alla GCS (classe \texttt{Vehicle} coaudivata da un'istanza di \texttt{LinkManager}) e dei messaggi di cui è stato svolto il \textit{parsing} dalla libreria \textsc{MAVLink} (classe \texttt{MAVLinkProtocol}: presente nella sottodirectory \texttt{comm/}).

La comunicazione con l'UAV connesso avviene mediante \textbf{datagrammi UDP} gestiti da un \texttt{LinkManager} che contengono messaggi \textsc{MAVLink} costruiti utilizzando le funzioni della libreria C di questo progetto.

Al contrario di quanto avviene nel contesto di ArduPilot, con QGroundControl suddetta libreria \textbf{non viene generata} al momento della compilazione ma viene fatto uso dell'\textbf{implementazione di riferimento in C} \cite{mavlink-c-implementation} messa a disposizione pubblicamente da DroneCode su GitHub ed inclusa nella repo di QGroundControl utilizzando (ancora una volta) il meccanismo dei \textit{submodules}.

Il "dialetto" utilizzato di default da QGroundControl per la libreria \textsc{MAVLink} è (a partire dal 24 agosto 2023)\cite{qgc-all-commit} \texttt{all}, ma tale aspetto può essere variato in uno dei \textbf{file di configurazione del progetto}: \texttt{QGCExternalLibs.pri}.

Per quanto riguarda questo lavoro, invece, viene ancora utilizzato il "dialetto" \texttt{ArduPilotMega} poiché tale cambiamento non era stato proposto ed approvato. \footnote{Cambiamenti così importanti sono particolarmente frequenti in progetti open source del genere, ndr}

\subsubsection{Ottenere QGroundControl}
La natura open source e cross platform di tale progetto permette a chi è interessato di ottenerne una copia sostanzialmente in due modi:

\begin{enumerate}
    \item Utilizzando una \textbf{release} periodica precompilata;
    \item Compilando (ed eventualmente modificando!) il codice sorgente, approccio utilizzato tra l'altro nel presente lavoro.
\end{enumerate}

Per quanto riguarda la (1.), pacchetti precompilati sono disponibili nella sezione "release" di GitHub, dove sono presenti di solito:

\begin{itemize}
    \item Un file \texttt{.exe} che permette l'installazione su Microsoft Windows;
    \item Un'immagine disco \texttt{.dmg} montabile ed installabile su macOS;
    \item Un'\textit{AppImage} compatibile la maggior parte delle distro GNU/Linux;
    \item Un file apk installabile su Android.
\end{itemize}

Per quanto riguarda la (2.), sono naturalmente necessari particolari accorgimenti, oltre ad una piattaforma che permetta di compilare agevolmente un progetto di grandi dimensioni.\footnote{Gli step riportati qui di seguito si riferiscono al sistema operativo \textbf{Ubuntu 20.04 LTS}, lo stesso utilizzato per il lavoro presentato.}

In particolare:

\begin{enumerate}
    \item È necessario installare il framework \textbf{Qt}, mediante l'online installer oppure tramite tool di terze parti \cite{aqtinstall}. La versione di Qt necessaria attualmente è, secondo quanto indicato \cite{build-qgc}, la 5.15.2;
    \item Tramite il gestore pacchetti \texttt{apt} è necessario installare i seguenti pacchetti:
        \begin{itemize}
            \item \texttt{speech-dispatcher};
            \item \texttt{libudev-dev};
            \item \texttt{libsdl2-dev};
            \item \texttt{patchelf};
            \item \texttt{build-essential};
            \item \texttt{curl} (che probabilmente è già installato di default).
        \end{itemize}
\end{enumerate}

Successivamente è necessario preparare l'ambiente di build mediante i seguenti comandi nella \textit{root} della repository:

\begin{center}
    \texttt{mkdir build/ \&\& cd build/} \\
    \texttt{qmake ../}
\end{center}

L'invocazione di \texttt{qmake} permette a Qt di inizializzare i \textbf{Makefile} ed di caricare le \textbf{variabili d'ambiente} contenute nei \textbf{file di configurazione} (come ad esempio il dialetto di \textsc{MAVLink} da utilizzare, già accennato in precedenza).

È ora finalmente possibile invocare \texttt{make} per iniziare la procedura di compilazione vera e propria:

\begin{center}
    \texttt{make -j\$(nproc -{}-all)}
\end{center}

Il comando \texttt{nproc -{}-all} permette di determinare il numero di core logici che la CPU della macchina su cui si sta svolgendo la compilazione ha a disposizione. Ciò permette una compilazione veloce quanto più possibile.

Una volta terminata la compilazione del software, l'eseguibile prodotto sarà posizionato all'interno della cartella \texttt{build/staging} e si chiama semplicemente \texttt{QGroundContol}. Suddetto file ha già assegnati i permessi di esecuzione ed è possibile eseguirlo mediante il seguente comando:

\begin{center}
    \texttt{staging/QGroundControl}
\end{center}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/QGroundCotrol-Interface.jpg}
    \caption{L'interfaccia di QGroundContol una volta aperto}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/QGroundControl-settings.jpg}
    \caption{Le impostazioni di QGroundContol}
\end{figure}

\section{Il protocollo \textsc{MAVLink}}

Come accennato in fase di introduzione a questo lavoro, il \textbf{protocollo \textsc{MAVLink}} è il vero e proprio "collante" tra le due parti della comunicazione, ovvero l'UAV e la GCS a terra. In questa sezione viene presentata la filosofia, le specifiche e l'architettura del protocollo \textsc{MAVLink} e se ne illustra l'evoluzione con il passare del tempo.

\subsection{Principi di funzionamento}
Il protocollo \textsc{MAVLink} (nome breve per \textbf{M}icro \textbf{A}erial \textbf{V}ehicle \textbf{Link}) è stato proposto per la prima volta nel 2010 dallo sviluppatore \textbf{Lorenz Meier} \cite{mavlink-first-commit} e si propone come un protocollo basato su \textbf{scambio di messaggi} che ha come caratteristica principale quello di essere \textbf{lightweight}: alla luce del contesto in cui si sta operando, quest'ultima caratteristica risulta essere particolarmente desiderabile.

\begin{wrapfigure}{r}{0.50\textwidth}
    \includegraphics[width=0.9\linewidth]{images/logo_mavlink_small.png}
    \caption{Logo del progetto} 
\end{wrapfigure}

Il principio di funzionamento del protocollo \textsc{MAVLink} è tipico di altri protocolli di tipo \textbf{publish-subscribe}, in quanto le due parti della comunicazione (l'UAV e la GCS) pubblicano \textbf{messaggi \textsc{MAVLink}} su un \textbf{topic} a cui sono entrambi iscritti. 

La particolarità di questo protocollo risiede nella sua \textbf{duttilità} poiché (al contrario di quanto potrebbe suggerire il suo nome) può essere utilizzato per dispositivi diversi da quelli comunemente definiti come "droni". D'altronde, il progetto ArduPilot lo utilizza anche nei progetti che riguardano Rover e Sub.

Come menzionato in precedenza, l'implementazione di riferimento di questo protocollo è disponibile su \textbf{GitHub} e si configura come una libreria \textbf{header-only} scritta nel linguaggio di programmazione C e che può essere liberamente integrata nei progetti che intendono farne uso, secondo la licenza LGPL. \cite{mavlink-c-implementation}

Altra particolarità di questo protocollo è la sua \textbf{estensibilità}: è presente un \textbf{pool} di messaggi standard che permettono una corretta e completa a 360° comunicazione tra UAV e GCS ma è possibile aggiungerne liberamente degli altri per introdurre un comportamento personalizzato, ottenere informazioni non standard e \textbf{scambiare dati} di conseguenza. 

Proprio questo ultimo aspetto è stato determinante per il lavoro presentato.

Data la sua estensibilità sono stati stabiliti, col passare del tempo, diverse varianti (o \textbf{dialetti}) di \textsc{MAVLink}, alcuni di questi "supportati ufficialmente". Ad esempio:

\begin{itemize}
    \item \texttt{minimal}: il "minimo indispensabile", ovvero quei messaggi che vanno implementati su ogni veicolo pena il non funzionamento del protocollo;
    \item \texttt{common}: il sottoinsieme dei messaggi più \textbf{comuni} che \textit{andrebbero} messi a disposizione su tutti i veicoli. Naturalmente, include \texttt{minimal};
    \item \texttt{ardupilotmega}: i messaggi \textsc{MAVLink} usati dal progetto \textbf{ArduPilot}, include \texttt{common};
    \item \texttt{ASLUAV}: i messaggi \textsc{MAVLink} utilizzati per veicoli ad ala fissa denominati \textbf{ASLUAV};
    \item \texttt{uAvionix}: i messaggi \textsc{MAVLink} utilizzati dal progetto \textbf{uAvionix};
    \item \texttt{paparazzi}: i messaggi \textsc{MAVLink} utilizzati dall'autopilot \textbf{paparazzi};
    \item \texttt{all}: una collezione di tutti i messaggi definiti in precedenza.
\end{itemize}

Le definizioni di questi messaggi sono contenute in dei file XML presenti nella repo GitHub del progetto. In ciascuno di questi è presente la direttiva \texttt{<include></include>} che permette la definizione di \textbf{gerarchie di messaggi}. \cite{mavlink-message-definitions}

La caratteristica che rende lightweight tale protocollo è il modo in cui i messaggi \textsc{MAVLink} viaggiano sul link di comunicazione: essi vengono infatti \textbf{serializzati} in forma \textbf{binaria} \cite{mavlink-overview}, operazione che ne facilita di molto il parsing, con un \textit{gain} prestazionale non indifferente rispetto al parsing da altri formati \textbf{text-based} come JSON o XML, usati tipicamente in contesti in cui le risorse a disposizione non sono limitate, al contrario di quanto avviene nel caso degli UAV.

Con il passare del tempo sono state proposte \textbf{due revisioni maggiori} del protocollo \textsc{MAVLink}:

\begin{itemize}
    \item La versione \textbf{1.0}, standardizzata nel 2013 \cite{mavlink-versions};
    \item La versione \textbf{2.0}, le cui migliorie sono descritte nella sezione successiva, rilasciata nella prima parte del 2017 \cite{mavlink-2}.
\end{itemize}

Fino al 2013 era inoltre ampiamente utilizzata la versione \textbf{0.9} del protocollo, deprecata con l'adozione da parte dei vari progetti della versione 1.0.

\newpage
\subsection{Architettura di un pacchetto \textsc{MAVLink}}

Un pacchetto \textsc{MAVLink}, al netto delle differenze tra le due revisioni, è composto sostanzialmente da due parti:

\begin{itemize}
    \item Un \textbf{header} che contiene delle informazioni di controllo;
    \item Un \textbf{payload} che contiene i dati veri e propri scambiati nel pacchetto.
\end{itemize}

\subsubsection{\textsc{MAVLink} 1.0: struttura di un pacchetto}
Un \textbf{frame} \textsc{MAVLink} 1.0 è strutturato come segue \cite{mavlink-1-packet}:

\begin{itemize}
    \item Start of Text (\texttt{STX}, chiamato anche \texttt{MAGIC}): un byte che rappresenta l'inizio di un frame \textsc{MAVLink}. Nella versione 1.0 del protocollo questo byte assume un valore fisso: \texttt{0xFE};
    \item Payload Length (\texttt{LEN}): un byte che rappresenta la \textbf{lunghezza in byte} del payload. Poiché questo campo è formato da un solo byte, la lunghezza del payload \textbf{non può superare i 255 bytes};
    \item Packet Sequence Number (\texttt{SEQ}): un byte che rappresenta il numero di sequenza del pacchetto nel contesto di una comunicazione. Serve principalmente per la \textbf{detection} di \textbf{perdita} dei pacchetti e degli errori in generale;
    \item System ID (\texttt{SYSID}): un byte che rappresenta l'ID del \textbf{mittente} del messaggio. Non è possibile indicare 0 (l'indirizzo di broadcast) come mittente poiché viene interpretato come non valido dal parser;
    \item Component ID (\texttt{COMPID}): un byte che rappresenta la \textbf{componente} del veicolo che ha generato il messaggio (una videocamera o un qualche accessorio);
    \item Message ID (\texttt{MSGID}): un byte che rappresenta il \textbf{Message ID} del contenuto del payload. Serve alla libreria per identificare il messaggio eselezionare il parser più adatto per interpretare il contenuto e deserializzarlo;
    \item Payload (\texttt{PAYLOAD}): un vettore di byte di \textbf{al più} 255 bytes (si veda il ragionamento fatto in precedenza) che contiene i dati veri e propri scambiati tra l'UAV e la GCS;
    \item CRC (+ CRC Extra) (\texttt{CHECKSUM}): due bytes: \begin{itemize}
        \item Il primo rappresenta il checksum del messaggio (nel suo calcolo non viene considerato \texttt{STX});
        \item Il secondo (denominato \texttt{CRC\_EXTRA}) rappresenta il CRC della \textbf{struttura della definizione XML del messaggio}. Ciò permette alle due parti della comunicazione di assicurarsi di star considerando messaggi definiti allo stesso modo.
    \end{itemize}
\end{itemize}

Di seguito è presente un riepilogo della struttura di un pacchetto \textsc{MAVLink} nella sua revisione 1.0:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/packet_mavlink_v1.jpg}
    \caption{La struttura di un messaggio \textsc{MAVLink} 1.0}
\end{figure}

Per quanto riguarda la dimensione dei pacchetti \textsc{MAVLink} 1.0:

\begin{itemize}
    \item La dimensione \textbf{minima} di un pacchetto \textsc{MAVLink} 1.0 è di 8 bytes (quando \textbf{non} è presente un payload, tipicamente quando si ha a che fare con dei pacchetti di ACK);
    \item La dimensione \textbf{massima} di un pacchetto \textsc{MAVLink} 1.0 è di 263 bytes (8 bytes di header + 255 bytes di payload, quando quest'ultimo è completamente "riempito").
\end{itemize}

\newpage

\subsubsection{\textsc{MAVLink} 2.0: struttura di un pacchetto}

Con il rilascio della versione 2.0 delle specifiche del protocollo, la struttura di un pacchetto è variata leggermente.

In particolare:

\begin{itemize}
    \item Sono stati aggiunti due nuovi membri dell'header: \texttt{CMPFLAGS} e \texttt{INCFLAGS};
    \item È stato aggiunto il supporto alla \textbf{firma digitale del pacchetto};\\
\end{itemize}
Un frame \textsc{MAVLink} 2.0 è quindi strutturato come segue \cite{mavlink-2-packet}:

\begin{itemize}
    \item Start of Text (\texttt{STX}, chiamato anche \texttt{MAGIC}): un byte che rappresenta l'inizio di un frame \textsc{MAVLink}. Nella versione 2.0 del protocollo questo byte assume un valore fisso: \texttt{0xFD};
    \item Payload Length (\texttt{LEN}): un byte che rappresenta la \textbf{lunghezza in byte} del payload. Poiché questo campo è formato da un solo byte, la lunghezza del payload \textbf{non può superare i 255 bytes};
    \item Incompatibility Flags (\texttt{INCFLAGS}): un byte che rappresenta quelle features del protocollo che \textbf{devono essere tassativamente supportate} da chi riceve il pacchetto poiché \textbf{ne alterano la struttura}. In caso contrario, le specifiche del protcollo indicano che il pacchetto deve essere \textbf{scartato}. L'unico valore attualmente supportato è \texttt{0x01}, che rappresenta la possibilità di \textbf{firmare il messaggio};
    \item Compatibility Flags (\texttt{CMPFLAGS}): un byte che indica la presenza di features "aggiuntive" che, anche se non supportate dal ricevente \textbf{non pregiudicano} la deserializzazione del pacchetto e che quindi lo scarto delpacchetto non è per forza necessario. Un esempio è una flag che denota un pacchetto "ad alta priorità".
    \item Packet Sequence Number (\texttt{SEQ}): un byte che rappresenta il numero di sequenza del pacchetto nel contesto di una comunicazione. Serve principalmente per la \textbf{detection} di \textbf{perdita} dei pacchetti e degli errori in generale;
    \item System ID (\texttt{SYSID}): un byte che rappresenta l'ID del \textbf{mittente} del messaggio. Non è possibile indicare 0 (l'indirizzo di broadcast) come mittente poiché viene interpretato come non valido dal parser;
    \item Component ID (\texttt{COMPID}): un byte che rappresenta la \textbf{componente} del veicolo che ha generato il messaggio (una videocamera o un qualche accessorio);
    \item Message ID (\texttt{MSGID}): \textbf{tre bytes} che rappresentano il \textbf{Message ID} del contenuto del payload. Serve alla libreria per identificare il messaggio eselezionare il parser più adatto per interpretare il contenuto e deserializzarlo. Con l'aumento della dimensione di questo campo è possibile supportare un numero più grande di messaggi e di rendere la libreria ancora più flessibile rispetto a prima;
    \item Payload (\texttt{PAYLOAD}): un vettore di byte di \textbf{al più} 255 bytes (si veda il ragionamento fatto in precedenza) che contiene i dati veri e propri scambiati tra l'UAV e la GCS;
    \item CRC (+ CRC Extra) (\texttt{CHECKSUM}): due bytes: \begin{itemize}
        \item Il primo rappresenta il checksum del messaggio (nel suo calcolo non viene considerato \texttt{STX});
        \item Il secondo (denominato \texttt{CRC\_EXTRA}) rappresenta il CRC della \textbf{struttura della definizione XML del messaggio}. Ciò permette alle due parti della comunicazione di assicurarsi di star considerando messaggi definiti allo stesso modo.
    \end{itemize}
\end{itemize}

Oltre all'header ed al payload, il protocollo \textsc{MAVLink} 2.0 introduce anche la possibilità di aggiungere (\textit{append}) una \textbf{firma digitale} ad un frame. Tale campo è lungo esattamente \textbf{13 bytes}.

\newpage

Di seguito è presente un riepilogo della struttura di un pacchetto \textsc{MAVLink} nella sua revisione 2.0:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/packet_mavlink_v2.jpg}
    \caption{La struttura di un messaggio \textsc{MAVLink} 2.0}
\end{figure}

Alla luce di tutte le informazioni qui sopra riportate, riguardo la dimensione di un frame \textsc{MAVLink} 2.0 è possibile menzionare che:

\begin{itemize}
    \item La dimensione \textbf{minima} di un pacchetto \textsc{MAVLink} 2.0 (senza payload e senza firma) è di \textbf{12 bytes};
    \item La dimensione \textbf{massima} di un pacchetto \textsc{MAVLink} 2.0 (con payload "riempito" e con apposta una firma digitale) è di \textbf{280 bytes} (\textbf{12} bytes di header + \textbf{255} bytes di payload + \textbf{13} bytes di firma). 
\end{itemize}

\subsubsection{La firma digitale in \textsc{MAVLink} 2.0}
Come menzionato, a partire dalla versione 2.0 del protocollo \textsc{MAVLink} è stato aggiunto il supporto alla firma digitale dei frame. La struttura dell'header della firma del pacchetto risulta essere grande 13 bytes, così strutturati \cite{sign-frame-fotmat}:

\begin{itemize}
    \item \textbf{Link ID} (\texttt{LINK ID}): un byte che rappresenta il \textbf{link} su cui è stato inviato un determinato pacchetto;
    \item \textbf{Timestamp} (\texttt{TM.STAMP}): \textbf{sei bytes} che rappresentano il numero di unità di 10 \textbf{microsecondi} passati dal \textbf{1 Gennaio 2015}. Questo contatore deve aumentare in maniera \textit{monotona} ad ogni messaggio inviato. Se ci si trova in un contesto in cui vengono inviati più di ~100.000 messaggi al secondo, questo timestamp può \textbf{superare} l'ora corrente;
    \item \textbf{Signature} (\texttt{SIGNATURE}): \textbf{sei bytes} (48 bit) che contengono la firma digitale vera e propria.
\end{itemize}

Di seguito è presente una rappresentazione grafica dell'header aggiuntivo della firma digitale.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/mavlink2-signature.png}
    \caption{La struttura dell'header di firma}
\end{figure}

Un pacchetto \textsc{MAVLink} firmato, come accennato in precedenza, è caratterizzato dal campo \texttt{INCFLAGS} impostato a \texttt{0x01}.

\newpage

\subsubsection{Algoritmo di generazione della firma digitale in \textsc{MAVLink} 2.0}

I \textbf{sei bytes} che compongono la firma digitale vera e propria sono ottenuti concatenando \cite{sign-algorithm}:

\begin{itemize}
    \item Una \textbf{chiave segreta} condivisa tra le due parti della comunicazione (\texttt{SECRET\_KEY});
    \item I bytes che compongono l'\textbf{header} del pacchetto (\texttt{HEADER});
    \item I bytes che compongono il \textbf{payload} del pacchetto (\texttt{PAYLOAD});
    \item I bytes che compongono il \textbf{CRC} dell'intero pacchetto (\texttt{CRC});
    \item I bytes che compongono il \textbf{Link ID} dell'header della firma (\texttt{LINKID});
    \item I bytes che compongono il \textbf{timestamp} dell'header della firma (\texttt{TM.STAMP}).
\end{itemize}

ed estraendo i primi \textbf{48 bit} dell'hash di questa sequenza ottenuto utilizzando l'algoritmo \textbf{SHA256}.

Ricapitolando:

\begin{center}
    \texttt{SIGN = SHA256\_48(SECRET\_KEY + HEADER + PAYLOAD + CRC + LINKID + TM.STAMP);}
\end{center}

dove \texttt{SHA256\_48} rappresenta il troncamento dell'hash prodotto ai primi \textbf{48 bit} e il simbolo \texttt{+} rappresenta la concatenazione tra bytes.

\newpage
\subsubsection{Scelta della versione del protocollo}
Poiché l'uso del protocollo \textsc{MAVLink} 1.0 è ancora ampiamente diffuso, è stato necessario implementare un meccanismo di "definizione" della versione del protocollo da utilizzare per una comunicazione: una sorta di \textbf{handshaking} \cite{version-handshaking} preliminare la cui struttura viene riportata di seguito:

\begin{itemize}
    \item La \textbf{Ground Control Station} invia il messaggio \texttt{MAV\_CMD\_REQUEST\_PROTOCOL\_VERSION} al drone, richiedendo quindi la versione del protocollo in uso dal veicolo ed iniziando contemporaneamente un \textit{countdown di timeout};
    \item L'UAV a questo punto può rispondere in due modi: \begin{itemize}
        \item Se è presente il supporto per il protocollo \textsc{MAVLink} 2.0, risponderà con il messaggio di ACK \texttt{PROTOCOL\_VERSION} formattato come frame \textsc{MAVLink} 2.0;
        \item Se invece non vi è supporto per \textsc{MAVLink} 2.0, risponderà con un \textbf{NACK} e, in caso di assenza di procedure apposite, \textbf{scarterà il messaggio precedente} e non risponderà affatto.
    \end{itemize}
    \item \begin{itemize}
        \item Se la GCS riceve il messaggio \texttt{PROTOCOL\_VERSION} allorà verrà effettuato lo \textit{switch} alla versione 2.0 del protocollo.
        \item Se viene ricevuto un NACK oppure si giunge al timeout, viene utilizzata la versione 1.0 del protocollo poiché evidentemente l'UAV non è riuscito ad interpretare in maniera corretta il frame precedente.
        \end{itemize} 
\end{itemize}

\newpage

Di seguito è presente una rappresntazione grafica dell'handshaking appena descritto.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/handshake_mavlink.jpeg}
    \caption{L'handshake effettuato per stabilire la versione del protocollo da utilizzare}
\end{figure}

\newpage

\section{Sicurezza del protocollo \textsc{MAVLink}}
\subsection{Possibili attacchi contro \textsc{MAVLink}}
Come qualsiasi protocollo che fa utilizzo di un mezzo trasmissivo, \textsc{MAVLink} non è di certo immune a determinati tipi di attacchi che vanno a colpire ognuno dei membri della cosiddetta triade \textbf{CIA}, ovvero:

\begin{itemize}
    \item \textbf{C}onfidentiality;
    \item \textbf{I}ntegrity;
    \item \textbf{A}vailability
\end{itemize}

Inoltre, l'intrinseca natura di \textsc{MAVLink} come protocollo \textbf{lightweight} implica un maggior focus sulle performance e sulla portabilità del protocollo piuttosto che sulla \textbf{sicurezza} dello stesso.

In uno studio \cite{8425627} del 2019, \textbf{Kwon et al.} hanno svolto un'analisi delle possibili vulnerabilità che affliggono il protocollo \textsc{MAVLink}. Tra queste si annoverano:

\begin{itemize}
    \item \textbf{Man-in-the-middle}, che permette ad un attaccante di posizionarsi dal punto di vista logico "al centro" di una comunicazione tra un drone e la sua GCS. Questo è un attacco che viola la confidenzialità e (specialmente) l'integrità della comunicazione;
    \item \textbf{Eavesdropping}, che permette ad un attaccante di "origliare" (\textit{eavesdrop}) la conversazione tra un drone e la sua GCS. Questo attacco viola la confidenzialità della comunicazione;
    \item \textbf{DoS - Denial of Service}, che permette ad un attaccante di operare in maniera tale da rendere uno o anche entrambi gli apparati coinvolti della comunicazione non in grado di continuarla. Questo è un attacco all'avalilability. Ciò può avvenire tramite flooding (attacchi "rumorosi") o mediante lo sfruttamento di determinate vulnerabilità o errori di configurazione degli apparati stessi (attacchi "non rumorosi").
\end{itemize}

Gli autori dello studio menzionano due tipologie di attacchi portati a termine con successo, testati mediante \textbf{SITL} ed ArduPilot \textbf{Mission Control}:

\begin{itemize}
    \item Attacco basato su \textbf{ICMP flooding}, che permette di saturare i due endpoint della comunicazione, modificando pesantemente la \textbf{varianza} dei temPI DI \textit{inter-ricezione} dei pacchetti, rendendo quindi la comunicazione \textbf{instabile};
    \item Attacco basato su \textbf{packet injection}, che permette ad un attaccante di effettuare l'\textbf{hijacking} della comunicazione tra drone e GCS ed è basata su una vulnerabilità del \textbf{Waypoint Protocol}. In breve, quando un UAV riceve il comando \texttt{MISSION\_COUNT(N)} da parte della GCS cancella tutte le informazioni relative alla missione che stava eseguendo e resta in attesa di indicazioni sulla nuova missione da eseguire. L'iniezione di un pacchetto di questo tipo permette ad un attaccante di "iniettare" una nuova missione da eseguire magari creata ad-hoc.
\end{itemize}

Inoltre, il fatto che il protocollo \textsc{MAVLink} non preveda alcun tipo di cifratura dei pacchetti in transito \cite{mavlink-no-encrypt} implica una intrinseca insicurezza dello stesso poiché tutte le informazioni sono scambiate in chiaro, rendendo quindi possibile gli attacchi di cui sopra.

\subsection{Possibili contromisure}
La versione 2.0 di \textsc{MAVLink}, che introduce il sistema della firma digitale dei pacchetti mette \textbf{solo parzialmente} una pezza alle problematiche descritte poiché previene il \textbf{tampering} delle comunicazioni ma non risolve le problematiche relative alla \textbf{confidenzialità}. In ogni caso, il fatto che suddetta firma sia grande solamente \textbf{48 bit} apre la porta a tutta un'altra serie di attacchi basati su \textbf{bruteforcing}.

Data la sempre maggiore attenzione riservata a questo tipo di dispositivi in particolare nell'ultimo decennio, il problema della messa in sicurezza dei protocolli come il \textsc{MAVLink} ha acquisito sicuramente un'importanza maggiore. Il problema, inoltre, viene reso ancora più difficile dal fatto che si renda necessario fare un \textbf{tradeoff} tra il grado di sicurezza del protocollo e l'alto \textbf{\textit{throughput}} che lo stesso deve offrire pur trovandosi in contesti caratterizzati da risorsehardware tutt'altro che illimitate.

Negli ultimi anni sono stati, in effetti, compiuti alcuni passi in avanti in questo senso grazie a diversi lavori di ricerca.

\subsubsection{MAVSec}
In uno studio \cite{DBLP:journals/corr/abs-1905-00265} pubblicato nel Maggio del 2019, \textbf{Allouch et al.}, oltre ad un'ulteriore overview delle potenziali vulnerabilità insite nel protocollo \textsc{MAVLink} hanno proposto una soluzione che potesse risolvere la problematica della \textbf{confidenzialità} della comunicazione introducendo una sorta di \textit{framework} denominato \textbf{MAVSec}, che prevede di modificare i progetti \textbf{ArduPilot}, \textbf{QGroundControl} e la libreria \textbf{\textsc{MAVLink}} (nella sua implementazione di riferimento in C) al fine di supportare diversi algoritmi di cifratura \textbf{simmetrica} da applicare al \textbf{payload} dei messaggi \textsc{MAVLink} prima della loro immissione nel mezzo trasmissivo.

Gli algoritmi considerati nello studio comprendono:

\begin{itemize}
    \item \texttt{AES} in modalità \textbf{CBC};
    \item \texttt{AES} in modalità \textbf{CTR};
    \item \texttt{RC4} (usato tra l'altro dal protocollo di sicurezza WEP);
    \item \texttt{ChaCha20}.
\end{itemize}

Gli autori dello studio hanno confrontato le performance di questi algoritmi sostanzialmente in tre macro-aree:

\begin{itemize}
    \item \textbf{Consumo di memoria} da parte dell'UAV;
    \item \textbf{Numero di frame} inviati al secondo;
    \item \textbf{Consumo di CPU} da parte dell'UAV.
\end{itemize}

Dai risultati della ricerca emerge che l'algoritmo migliore in \textbf{tutti} questi campi risulti essere \texttt{ChaCha20}.

Tale algoritmo è stato proposto nel 2008 in un paper \cite{chacha20} pubblicato da \textbf{Daniel J. Bernstein} e si configura come un \textbf{cifrario a blocchi} variante di \texttt{Salsa20/20} che permette di migliorarne la resistenza ad attacchi basati su \textbf{crittoanalisi} riducendo in alcuni casi il tempo di esecuzione di ogni round. Il \texttt{20} all'interno del nome è dovuto al numero di round che vengono effettuati durante l'esecuzione dell'algoritmo. In generale, i membri della famiglia ChaCha consistono:

\begin{itemize}
    \item \texttt{ChaCha8}, derivato dall'algoritmo \texttt{Salsa20/8} e che prevede \textbf{8 rounds};
    \item \texttt{ChaCha12}, derivato dall'algoritmo \texttt{Salsa20/12} e che prevede \textbf{12 rounds};
    \item Il già citato \texttt{ChaCha20}.
\end{itemize}

\subsubsection{Securing Unmanned Aerial Vehicles by Encrypting \textsc{MAVLink} Protocol}

In un successivo studio \cite{10037546} pubblicato alcuni anni più tardi, nel 2022, \textbf{Sabuwala et al.} proposero uno studio simile a quello menzionato in precedenza, prendendo però in considerazione algoritmi diversi. In particolare:

\begin{itemize}
    \item \texttt{ChaCha20}, come nel caso dello studio precedente;
    \item \texttt{Encryption by Navid}, una tecnica di cifratura basata (in parte) su un \textbf{Cifrario di Cesare};
    \item \texttt{DMAV}, uno schema di cifratura basata su una codifica denominata "DNA dinamica" proposto in uno studio del 2022. 
\end{itemize}

I risultati di questo studio confermano, in un certo senso, quellid el precedente, determinando come l'algoritmo \texttt{ChaCha20} \textbf{sia il migliore dei tre confrontati} negli ambiti di \textbf{pacchetti inviati al secondo}, \textbf{consumo di memoria nell'UAV}, \textbf{percentuale di CPU} in uso nell'UAV.

Si noti come in entrambi i casi sia stato utilizzato il progetto ArduPilot ed in particolare il già citato software \textbf{SITL} per condurre i test.

\subsubsection{Sicurezza in ambienti resource-constrained: una breve introduzione al concetto di lightweight cryptography}
Più o meno nello stesso periodo in cui si il panorama delle piattaforme hardware e software per UAV si è arricchiato e l'utilizzo di questi dispositivi è e andata "democratizzandosi", si è assistito, in generale, alla sempre più capillare di dispositivi "intelligenti" da utilizzare nei contesti più disparati. Nasce quindi il concetto di \textbf{Internet of Things} (comunemente definito con il suo acronimo \textbf{IoT}), che condivide un discreto numero di aspetti sia positivi che negativi con il contesto dell'UAV. 

Certamente, si ritrova in entrambi i casi la necessità dell'utilizzo di protocolli leggeri ed efficienti ma anche (e soprattutto) i limiti delle piattaforme hardware che permettono il funzionamento dei dispositivi (quindi tipicamente microcontrollori dotati di funzionalità di rete). 

Vien da sé, quindi, che il discorso sulla generale insicurezza dei protocolli affrontato più volte in questo lavoro per gli UAV valga anche per i dispositivi IoT. 

Nondimeno, la capillare diffusione di tali dispositvi in ambienti domestici ed aziendali pone un'ulteriore problematica di \textbf{privacy} oltre che di \textbf{safety} e di \textbf{security} come invece avveniva nel caso degli UAV.

Per far fronte a questo tipo di criticità e al (necessario) tradeoff tra performance e requisiti di sicurezza, ecco che col passare del tempo sorge una nuova "branca" di ricerca nell'ambito della crittografia dedicata allo sviluppo di algoritmi (e di relative piattaforme \textit{ad-hoc} per la loro implementazione in hardware) pensati per funzionare in ambienti \textbf{resource-constrained}: la \textbf{lightweight cryptography}.

Come analizzato in una revisione della letteratura \cite{8370965} compiuta nel 2018 da \textbf{Sadkhan e Salman}, diversi studi sono stati proposti nel campo della crittografia leggera e che hanno portato alla definizione di nuovi schemi di cifratura \textbf{simmetrica} ed \textbf{asimmetrica}.

Nell'Agosto del 2018, inoltre, il \textbf{NIST}\footnote{\textbf{N}ational \textbf{I}nstitute of \textbf{S}tandards and \textbf{T}echnology, un importante ente statale americano} ha annunciato l'inizio del processo di standardizzazione \cite{nist-request-lwc} di algoritmi di crittografia leggera. Dopo \textbf{due rounds} di selezione, nel 2021 sono stati annunciati i 10 \textbf{finalisti} \cite{nist-finalists-lwc} di questo processo, ovvero:

\begin{itemize}
    \item \texttt{ASCON};
    \item \texttt{Elephant};
    \item \texttt{GIFT-COFB};
    \item \texttt{Grain128-AEAD};
    \item \texttt{ISAP};
    \item \texttt{Photon-Beetle};
    \item \texttt{Romulus};
    \item \texttt{Sparkle};
    \item \texttt{TinyJambu};
    \item \texttt{Xoodyak}.
\end{itemize}

Nel 2023, infine, l'algoritmo \texttt{ASCON} è stato dichiarato vincitore \cite{nist-ascon-lwc}.
\newpage
\subsubsection{\textsc{MAVLink} e lightweight cryptography}
In un lavoro di tesi \cite{sec-uav} proposto dallo studente \textbf{Angelo Passaro}, è stato proposto un approccio basato su crittografia leggera che riprendesse il framework e le tecniche presentate nel lavoro \textbf{MAVSec} menzionato in precedenza ed il cui codice è disponibile su GitHub \cite{mavsec-github}.

Tale lavoro si differenzia dai precedenti poiché va a sfruttare diverse caratteristiche del protocollo \textsc{MAVLink} e delle piattaforme software descritte nelle precedenti sezioni del lavoro qui presentato.

Sono stati considerati diversi algoritmi che appartengono al pool della crittografia leggera sia dal punto di vista della cifratura \textbf{simmetrica} che dal punto di vista degli algoritmi di \textbf{scambio delle chiavi} e sono stati condotti diversi test per stabilire quale fosse quello più conveniente rispetto ao criteri definiti in precedenza dagli altri studi.

In particolare, gli algoritmi di cifratura \textbf{simemtrica} integrati nel lavoro qui considerato consistono in:

\begin{itemize}
    \item \texttt{Trivium};
    \item \texttt{Rabbit};
    \item \texttt{ChaCha20} (utilizzato principalmente negli altri studi);
    \item \texttt{Simon \& Speck};
\end{itemize}

Per quanto riguarda invece il concetto di scambio delle chiavi, nel lavoro considerato in questa sezione vengono discussi i risultati di uno studio \cite{10.1007/978-3-319-48799-1_58} presentato nel 2017 da \textbf{Alvarez et al.} che propone un confronto tra i seguenti \textit{meccanismi} di scambio delle chiavi:

\begin{itemize}
    \item \texttt{RSA};
    \item \texttt{DH}: scambio delle chiavi \textbf{Diffie-Hellman};
    \item \texttt{ECDH}: meccanismo di scambio delle chiavi ispirato a Diffie Hellman ma che si basa sul concetto di \textbf{curva ellittica};
    \item \texttt{Curve25519}: altro meccansimo di scambio delle chiavi basato su \textbf{curve ellittiche} che mira a migliorare le prestazioni rispetto ad \texttt{ECDH};
    \item \texttt{FourQ}: ulteriore meccanismo basato su curve ellittiche proposto da \textbf{Microsoft} nel 2015.
\end{itemize}

I risultati raggiunti nel paper menzionato in precedenza suggeriscono che gli algoritmi basati su \textbf{curve ellittiche} offrano le migliori prestazioni ed un minore consumo di risorse (memoria e percentuale di CPU utilizzata) ed in particolare, \texttt{FourQ} risulta prevalere sugli altri algoritmi del pool considerato.

Proprio per questa ragione, l'algoritmo che sta alla base del meccanismo di scambio delle chiavi implementato nel lavoro di Angelo Passaro consiste proprio in \texttt{FourQ}.

Dal punto di vista tecnologico, invece, sono state utilizzate le stesse piattaforme considerate negli altri studi menzionati in precedenza, ovvero:

\begin{itemize}
    \item \textbf{ArduPilot} perl'utilizzo di SITL;
    \item \textbf{QGroundContol} per controllare il simulatore;
    \item \textbf{\textsc{MAVLink}} (nella sua implementazione di riferimento in C) per integrare i nuovi messaggi per lo scambio delle chiavi e gestire cifratura e decifratura.
\end{itemize}

Il lavoro proposto in questo elaborato ricalca il framework stabilito da \textbf{MAVSec} prima e dal lavoro di \textbf{Angelo Passaro} poi dal punto di vista delle modifiche introdotte nello stack tecnologico, adattandolo poi al contesto della \textbf{Post-Quantum Cryptography}. 

Una descrizione tecnica approfondita dell'implementazione effettuata verrà svolta nel \textbf{Capitolo 6}.

\newpage
\section{Quantum Comuting e Post-Quantum Cryptography}
In questo capitolo verrà svolta una breve introduzione al concetto di \textbf{Quantum Computing} e si discuteranno le implicazioni della sua diffusione, tra gli altri, nel campo della crittografia.

\subsection{Cos'è il Quantum Computing}
Sebbene il concetto di Quantum Computing stia acquisendo sempre più importanza negli ultimi decenni, l'idea che sta alla sua base risale ai \textbf{primi anni '80} del XX secolo, quando in uno studio \cite{Benioff1980} del fisico statunutense \textbf{Paul Benioff} (venuto a mancare di recente, nel marzo del 2022) venne proposto un primo modello di \textbf{macchina di Turing} operante sotto le leggi della \textbf{meccanica quantistica}. Da quel momento molti altri studi vennero basati su questa idea: tra questi annoveriamo quello proposto da \textbf{Richard Feynmann} a proposito della simulazione di fenomeni fisici usando computer quantistici.

La vera differenza che intercorre tra un computer classico ed una macchina quantistica consiste nel modo in cui sono rappresentate le informazioni: se nel caso "classico" a noi familiare si ragiona in termini di \texttt{bit} (ovvero la più piccola unità con cui possono essere codificate delle informazioni), nel caso quantistico si passa al concetto di \texttt{\textbf{qubit}}, termine coniato nel 1995 \cite{PhysRevA.51.2738} dal fisico Benjamin Schumacher che rappresenta l'unità di informazione quantistica. 

Se nel contesto della computazione "classica" gli \textbf{stati} possibili che un bit può assumere sono solamente due: lo stato "0" e lo stato "1", nel contesto quantistico il confine tra gli stati che un qubit può assumere è in un certo senso più \textbf{labile}, in accordo con il fenomeno quantistico della \textbf{sovrapposizione tra stati}.

Un qubit può quindi trovarsi rispettivamente:

\begin{itemize}
    \item Nello stato \texttt{0} (con il 100\% di probabilità);
    \item Nello stato \texttt{1} (con il 100\% di probabilità);
    \item In una sovrapposizione di due stati: con il \texttt{p} di probabilità nello stato \texttt{0} e con probabilità \texttt{1 - p} nello stato \texttt{1}.
\end{itemize}

Al di là dei (comunque importanti e necessari) formalismi matematici, la conseguenza di usare un sistema basato su \texttt{qubit} al posto dei classici \texttt{bit} permette alle macchine che sfruttano questo sistema di ottenere performance nettamente maggiori a quelle dei computer tradizionali, tant'è che col passare del tempo questa tipologia di macchine sono state usate per provare a risolvere in tempo polinomiale problemi per cui non erano noti algoritmi "classici" efficienti.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{images/1280px-Bloch_Sphere.svg.png}
    \caption{La \textbf{sfera di Bloch}: una rappresentazione geometrica dei possibili stati in cui un \texttt{qubit} può trovarsi}
\end{figure}

\newpage

\subsection{Il problema: RSA, DH e l'algoritmo di Shor}
Uno degli esempi lampanti del potere computazionale notevolmente maggiore dei computer quantistici rispetto a quelli classici consiste nella pubblicazione di uno studio \cite{365700} da parte di \textbf{Peter W. Shor} nel 1994 che propone un \textbf{algoritmo} (conosicuto appunto come \textbf{Algoritmo di Shor}) per la fattorizzazione di interi.

Dal punto di vista teorico, tale algoritmo si configura come una \textbf{riduzione} dal problema della fattorizzazione di interi ad un problema di ricerca dell'\textbf{ordine} di un gruppo (inteso come struttura algebrica), anch'esso considerato come problema \textit{difficile} nel contesto della computazione classica. 

Si noti comunque che il processo di riduzione in sé avviene in tempo polinomiale anche in un computer tradizionale. 

Il \textit{core} dell'algoritmo proposto da Shor si occupa quindi di risolvere efficientemente (leggasi, \textit{tempo polinomiale}) il problema verso cui è stata effettuata la riduzione, seppur con un tasso di errore minore o uguale ad $\frac{1}{3}$ nel caso pessimo. La soluzione di tale problema, per com'è strutturato il processo dell riduzione di sicurezza implica la soluzione anche del problema "originale".

L'analisi della complessità dell'algoritmo proposto da Shor suggerisce che il suo tempo di esecuzione, comprensivo di tutte le operazioni descritte in precedenza sia proporzionale a:

\begin{center}
    $\mathcal{O}((log{}N)^2 (log{}log{}N))$
\end{center}

assumendo di utilizzare il metodo di \textbf{Harvey e Van Der Hoeven} \cite{harvey:hal-02070778} per la moltiplicazione efficiente di interi in tempo $\mathcal{O}(n log{}n)$ e che quindi il problema della fattorizzazione di interi appartenga, dal punto di vista della teroia della computazione, alla classe \textbf{BQP}, ovvero \textbf{la classe dei problemi risolvibili in tempo polinomiale mediante computer quantistici}.

L'approccio proposto da Shor, secondo quanto menzionato nel sommario dello studio, è applicabile non solo al problema della fattorizzazione di interi ma anche al problema del \textbf{logaritmo discreto}.

Le implicazioni dello studio di Shor sono enormi nel campo della crittografia poiché il problema della fattorizzazione di interi e del logaritmo discreto sono alla base degli schemi più utilizzati nel campo della crittografia asimmetrica (o a chiave pubblica): rispettivamente di \textbf{RSA} e del meccanismo di Key Exchange \textbf{Diffie Hellman}.

La risoluzione in tempo polinomiale mediante computer quantistici di tali problemi renderebbe del tutto insicuri tali schemi, ponendo un considerevole rischio correlato al funzionamento dei protocolli crittografici basati su problemi difficili, come appunto RSA e Diffie Hellman.

Tuttavia, vale la pena sottolinerare come il tasso di errore di tale algoritmo (dovuto al concetto di sovrapposizione degli stati) sia ancora troppo alto, pregiudicando quindi l'esecuzione dell'algoritmo anche sulle piattaforme più potenti allo stato attuale.

\newpage

\subsection{La soluzione: Post-Quantum Cryptography}
Il problema di situazioni del genere è che una volta note le modalità, ciò che manca è quindi la \textbf{potenza di calcolo}, che con l'avanzamento tecnologico sarà con ogni probabilità raggiunta col passare del tempo, ponendo quindi un rischio concreto per la sicurezza dei sistemi informatici (e non solo).

Proprio per regire a questo tipo specifico di minaccia, negli anni ha preso piede un nuovo concetto nel campo della crittografia, che permette di superare la minaccia posta dall'avvento del Quantum Computing: quello di \textbf{Post-Quantum Cryptography}.

Il grosso della ricerca in questo campo si è concentrato nel campo della crittografia a chiave pubblica e quindi nel contesto dello scambio di chiavi sicuro poiché è quello che fa affidamento su problemi diffcili come quelli descritti in precedenza (si pensi appunto ad RSA ed a Diffie Hellman).

Gli schemi crittografici che sono stati messi appunti nel contesto di questo nuovo campo di studi vengono divisi in diverse categorie, a seconda dell'approccio che adottano \cite{Bernstein2009}. Tra questi:

\begin{itemize}
    \item Approccio basato su \textbf{Reticoli}: l'approccio su cui si basa lo schema \texttt{Kyber} e che fa riferimento ad una struttura algebrica detta \textbf{Reticolo} e che include i sistemi crittografici basati sul problema \textbf{LWE} (acronimo per \textbf{Learning With Errors}) o su loro varianti;
    \item Approccio basato su \textbf{crittografia multivariata}: tale approccio si basa sulla difficoltà della risoluzione di \textbf{sistemi di equazioni multivariate};
    \item Approccio basato su \textbf{hash}, che si basa sull'assuzione della sicurezza delle \textbf{funzioni hash}. Esempi di schemi che sfruttano questo approccio consistono nello schema di firma digitale di \textbf{Merkle} o comunque altri schemi che usano il \textbf{Merkle Tree};
    \item Approccio basato su \textbf{codici}: ad esempio lo schema di cifratura di \textbf{McEliece}, che si basa sui \textbf{Codici di Goppa}.
\end{itemize}

Proprio l'attenzione riservata col passare del tempo a questo campo di ricerca, anche e soprattutto in seguito allo studio di Shor ed alla definizione del "suo" algoritmo, ha spinto il \textbf{NIST} a cercare di stabilire uno \textbf{standard} per algoritmi di cifratura a chiave pubblica resistenti ad attacchi con computer quantistici, un po' come successo (e menzionato in una precedente sezione del presente lavoro) con la crittografia leggera. 

A dicembre 2016 \cite{nist-pqc-nomination} venne rilasciata una \textbf{Request for Nomination} sul sito web del NIST, prima milestone nel processo di standardizzazione, con deadline fissata al 30 novembre 2017. 

Dopo quattro round di sottomissioni per tale processo, nel 2022 gli algoritmi selezionati dall'istituto sono i seguenti:

Per la crittografia a chiave pubblica:

\begin{itemize}
    \item \texttt{CRYSTALS-Kyber}.
\end{itemize}

Riguardo invece gli schemi di firma digitale:

\begin{itemize}
    \item \texttt{CRYSTALS-DILITHIUM};
    \item \texttt{FALCON};
    \item \texttt{SPHINCS+}
\end{itemize}

Si noti come nel caso della crittografia a chiave pubblica sia stato selezionato \textbf{un unico} algoritmo e che quindi è divenuto lo \textbf{standard} per questo tipo di schemi.

Anche nel contesto di questo lavoro, lo schema \texttt{Kyber} è stato quello scelto per eseguire operazioni di scambio chiavi.

Di seguito viene svolta una panoramica sulle basi e sulla struttura di tale schema crittografico.

\newpage
\subsection{L'algoritmo \texttt{Kyber}}
Come affermato in precedenza, \texttt{CRYSTALS-KYBER} è l'unico schema di cifratura selezionato dal NIST nel processo di standardizzazione.

Fa parte della suite \textbf{CRYSTALS} (acronimo di \textbf{Cryptographic Suite for Algebraic Lattices}) \cite{crystals} e si configura come "meccanismo di incapsulamento delle chiavi CCA-sicuro basato sulla difficoltà del problema LWE" \cite{crystals-kyber}.

Viene proposto alla comunità scientifica nel 2017 in uno studio \cite{cryptoeprint:2017/634} di \textbf{Joppe et al.} e successivamente valutato dal NIST per il processo di standardizzazione.

Prima di descrivere il funzionamento di tale schema è necessario fare una panoramica sulle sue basi matematiche e scientifiche, in particolare il concetto di KEM, il concetto di \textbf{Reticolo} ed il problema \textbf{LWE} (acronimo di \textbf{Learning with Errors}).

\subsubsection{KEM - Key Encapsulation Mechanism}
L'acronimo KEM è un abbreviazione per \textbf{Key Encapsulation Mechanism} ed è un particolare sistema crittografico \textit{ibrido} ed in particolare permette ai due "interlocutori" di una conversazione di utilizzare \textbf{un algoritmo di cifratura asimmetrica} per lo scambio di una chiave di cifratura da utilizzare nel contesto di un cifrario \textbf{simmetrico}. Naturalmente, il concetto di KEM non è solamente prerogativa della crittografia post quantistica ma è stato studiato ed implementato anche nel contesto della crittografia classica. Un esempio lampante ne è il KEM \textbf{basato sullo schema RSA} o su \textbf{curve ellittiche}, ampiamente utilizzati al giorno d'oggi.

Formalmente, un generico schema di incapsulamento KEM $K$ è una tupla di algoritmi \textbf{probabilistici di tempo polinomiale}:

\begin{center}
    \texttt{K = (Gen(), Encaps(), Decaps())}
\end{center}

dove:

\begin{itemize}
    \item \texttt{Gen(sec\_par)} è un algoritmo che si occupa di generare (e restituire) una \textbf{coppia di chiavi} \texttt{(pk, sk)} di una lunghezza determinata da \textbf{parametro di sicurezza} \texttt{sec\_par} dell'algoritmo. In particolare: \begin{itemize}
        \item \texttt{pk} rappresenta la \textbf{chiave pubblica};
        \item \texttt{sk} rappresenta la \textbf{chiave segreta}.
    \end{itemize}
    \item \texttt{Encaps(pk)} è l'algoritmo di \textbf{incapsulamento} che prende in input la chiave pubblica generatada da \texttt{Gen} e restituisce: \begin{itemize}
        \item \texttt{k}: una chiave segreta da usare con un cifrario simmetrico. Non deve essere inviata direttamente;
        \item \texttt{s}: un \textbf{testo cifrato}, ovvero la "capsula" che viene inviata all'altro membro della conversazione e che contiene la chiave \texttt{k} appena descritta.
    \end{itemize}
    \item \texttt{Decaps(s, sk)} è l'algoritmo di \textbf{decapsulamento} che prende in input: \begin{itemize}
        \item \texttt{s}: la capsula generata da \texttt{Encaps};
        \item \texttt{sk}: la chiave segreta generata da \texttt{Gen}.
    \end{itemize}

    E restituisce in output: \begin{itemize}
        \item \texttt{k}: la chiave che era stata incapsulata da \texttt{Encaps} se non si sono verificati errori.
    \end{itemize}
\end{itemize}

Questo tipo di costruzione crittografica si pone come \textbf{ibrido} tra uno schema di cifratura a chiave pubblica ed a chiave privata.

Si noti come, a differenza dei normali schemi di cifratura, non sia possibile scegliere un messaggio da incapsulare. Al contrario, \texttt{Encaps()} si occupa di scegliere la chiave simmetrica \texttt{k} e di incapsularla autonomamente.
\newpage
Di seguito è presente un diagramma che riassume il funzionamento di un generico KEM \texttt{K}, appena descritto formalmente.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/kem_scheme.png}
    \caption[If you see me then something's very broken]{Funzionamento di un Key Encapsulation Mechanism\protect\footnotemark}
\end{figure}

\footnotetext{\href{https://blog.cloudflare.com/post-quantum-key-encapsulation/}{Fonte dell'immagine}}

L'architettura di questo tipo di schemi di cifratura rimane sostanzialmente la stessa anche nel caso degli algoritmi post-quantum e l'algoritmo \texttt{Kyber} non fa eccezione. Il concetto che cambia è invece l'\textbf{assunzione} che sta alla base del funzionamento dello schema: nel caso classico i principali KEM utilizzati si basano sul problema \textbf{RSA} (e quindi sulla fattorizzazione di interi) e su \textbf{curve ellittiche} come menzionato in precedenza mentre algoritmi come \texttt{Kyber} si basano sul problema \textbf{LWE}, che può essere ricondotto ad un altro problema definito su un \textbf{Reticolo}, entrambi oggetti di discussione nelle prossime sezioni.
\newpage
\subsubsection{Reticoli}
Nelle sezioni precedenti sono stati presentati i vari approcci alla crittografia postquantistica. Uno di questi consisteva in quello basato su \textbf{Reticoli}.

Il nome "reticolo" (in inglese \textit{lattice}) usato senza contestualizzazione risulta essere fuorviante poiché vi sono collegati due concetti distinti, ovvero:

\begin{enumerate}
    \item \textbf{Reticolo} inteso come \textbf{struttura algebrica} o, equivalentemente, come \textbf{insieme parzialmente ordinato} tale che per ogni coppia di elementi $x$ ed $y$ è possibile individuare l'\textbf{estremo superiore} $Sup$ e l'\textbf{estremo inferiore} $Inf$. Tale tipologia di insiemi può essere rappresentato mediante un \textbf{diagramma di Hasse};
    \item \textbf{Reticolo} inteso come particolare \textbf{sottogruppo} dello spazio vettoriale $\mathcal{R}^n$.
\end{enumerate}

Il \textbf{secondo} concetto è quello utilizzato nel campo della crittografia.

Nel lavoro \textbf{Introduction to Post-Quantum Cryptography} \cite{Bernstein2009} è presente una definizione formale di reticolo nel capitolo dedicato a tale concetto, curato da \textbf{Daniele Micciancio} ed \textbf{Oded Regev}, che viene qui proposta.

Intuitivamente:
\begin{definition}
    Un reticolo è un insieme di punti in uno spazio $n$-dimensionale con una struttura periodica.
\end{definition}

Formalmente:

\begin{definition}
    Siano $b_1, b_2, ..., b_n \in \mathbb{R} ^n$ $n$ vettori linearmente indipendenti (dunque una \textbf{base} di $\mathbb{R}^n$), l'insieme definito come:

    \begin{center}
        \[\mathcal{L}(b_1,b_2,...,b_n) = \Biggl \{ \sum_{i = 1}^{n}x_ib_i \: : \: x_i \in \mathbb{Z} \Biggl\}\]
    \end{center}

    prende il nome di \textbf{reticolo}. I vettori $b_1, b_2, ..., b_n$ prendono il nome di \textbf{base} del reticolo.
\end{definition}

L'impiego di questo particolare concetto nel campo della crittografia deriva principalmente dalla definizione di alcuni problemi che si suppone generalmente essere \textbf{difficili}, come il problema \texttt{SVP} (acronimo per \textbf{Shortest Vector Problem}, che consiste nel trovare il vettore più piccolo all'interno di un reticolo) e, mediante opportune trasformazioni, del problema \texttt{LWE}, che sta alla base dell'algoritmo \texttt{Kyber} e che verrà ora descritto.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{images/Equilateral_Triangle_Lattice.svg.png}
    \caption{La rappresentazione di un reticolo su un piano euclideo}
\end{figure}

\newpage
\subsubsection{Il problema \texttt{LWE}}
Strettamente legato al problema \texttt{SVP} appena menzionato è il problema \texttt{LWE} (acronimo per \textbf{Learning with Errors}) poiché mediante un processo di \textbf{riduzione} \cite{10.1145/1060590.1060603} è possibile affermare che se (una variante del) problema \texttt{SVP} (ed in particolare \texttt{GapSVP}) è difficile, allora anche il problema \texttt{LWE} è difficile.

L'idea che sta informalmente alla base di questo problema consiste nel rappresentare determinate informazioni segrete aggiungendo un \textbf{errore} ad esse. 

Il problema \texttt{LWE}, nonostante si riduca ad un problema definito su reticoli, non è esso stesso un problema definito su reticoli ma un problema \textbf{algebrico}. 

In particolare, esso sfrutta alcune proprietà dei \textbf{sistemi di equazioni lineari}.

Infatti, un generico sistema della forma

\begin{center}
    $Ax = b$
\end{center}

(espresso in forma matriciale per ragione di compattezza) può essere risolto facilmente mediante uno dei metodi "classici" come quello di \textbf{sostituzione} o quello di \textbf{eliminazione di Gauss-Jordan}.

Tuttavia, se ad un sistema di questa forma viene aggiunto del "rumore", ovvero un certo vettore $e$ della forma:

\begin{center}
    $e = \begin{bmatrix}
        e_1 \\ e_2 \\ ... \\ e_n
    \end{bmatrix}$
\end{center}

facendo quindi diventare il sistema della forma 

\begin{center}
    $Ax + \mathbf{e} = b$
\end{center}

la situazione cambia drasticamente poiché \textbf{non è più possibile} utilizzare i metodi sopracitati per la risoluzione.

Il problema LWE è definito usando esattamente tale osservazione, anche se di solito per questo tipo di operazioni si tende a restringersi all'insieme degli interi $mod \: q$, con $q \in \mathbb{N}$.

Segue ora una definizione formale \cite{lwe-definition} del problema \texttt{LWE}.

\begin{definition}
    Sia $q \in \mathbb{N}$ e sia $\mathbb{Z}_q = \{0, 1, ..., q - 1\}$. Dati $m$ vettori $a_1, a_2, ..., a_m$ di $k$ componenti ciascuno (formalmente, definiti sull'insieme $\mathbb{Z}^k_q$), si definisca $s = \{s_1, s_2, ..., s_k\} \in \mathbb{Z}^k_q$ vettore \textbf{segreto} ed $e = \{e_1, e_2, ..., e_m\} \in \mathbb{Z}^m_q$ vettore degli \textbf{errori}.

    Si consideri un generico sistema di equazioni della forma:
    \[
        \left\{ 
        \begin{array}{l}
            \langle a_1, s \rangle + e_1 = b_1 \: (mod \: q) \\
            \langle a_2, s \rangle + e_2 = b_2 \: (mod \: q) \\
            \vdots \\
            \langle a_m, s \rangle + e_m = b_m \: (mod \: q)
        \end{array} 
    \right.
    \]

    che scritto in forma compatta (derivata da quella matriciale diventa):

    \begin{center}
        $A\mathbf{s} + e = b \: (mod \: q)$
    \end{center}

    Il problema \texttt{LWE} consiste, data una coppia $(A, b)$ ed un vettore $e$, trovare il "segreto" $s$. 

\end{definition}

Oltre alla variante del problema di \textbf{ricerca} appena mostrato esiste anche un problema \textbf{decisionale}, equivalente a questo.

L'algoritmo \texttt{Kyber} precedentemente menzionato si basa su una particolare variante del problema appena descritto, ovvero \texttt{ModuleLWE} \cite{cryptoeprint:2012/090}, a sua volta derivato dal problema \texttt{RingLWE} \cite{cryptoeprint:2012/230}.

La principale differenza tra il problema originale e i suoi "derivati" consiste nel fatto che l'insieme di riferimento non è più $\mathbb{Z}_q$ ma lo spazio dei polinomi a coefficienti in $\mathbb{Z}_q$, con la relazione $ X^n = - 1 $, formalmente: \[ R_q = \mathbb{Z}_q [X] / (X^n + 1)\]

Definiti i concetti matematici alla base della crittografia basata su \textbf{reticoli}, è possibile finalmente svolgere una panoramica sui principi di funzionamento dell'algoritmo \texttt{Kyber}, che nasce come uno schema di cifratura a chiave pubblica ma viene utilizzato comunemente come \textbf{KEM} e di conseguenza \textbf{standardizzato} come tale.

La descrizione del funzionamento di \texttt{Kyber} \cite{kyber-definition} ricalca sostanzialmente quella proposta per \texttt{LWE}, adattata per funzionare con l'insieme $R_q$.

\newpage
\subsubsection{\texttt{Kyber}: generazione delle chiavi}

La \textbf{chiave privata} in Kyber è composta da un \textbf{vettore di $k$ polinomi} con coefficienti relativamente piccoli, chiamato $s$;

La \textbf{chiave pubblica}, invece, è composta da una coppia $(A, t)$ in cui:

\begin{itemize}
    \item $A$ è una matrice di dimensione $k \times k$ di polinomi i cui coefficienti sono campionati in maniera casuale da $\mathbb{Z}_q$;
    \item $t$ è un ulteriore vettore di $k$ polinomi.
\end{itemize}

Il calcolo di $t$ dipende da $A$, da $s$ ma anche da un ulteriore vettore di $k$ polinomi con coefficienti relativamente piccoli, chiamato \textbf{vettore degli errori}.

Formalmente,

\[ t = As + e \]

utilizzando le operazioni di addizione e di prodotto riga per colonna.

Come accennato in fase di definizione del problema, risulta essere difficile (a causa del vettore $e$) recuperare $s$ a partire da $(A, t)$ poiché equivarrebbe a risolvere il problema \texttt{ModuleLWE}. 

\newpage
\subsubsection{\texttt{Kyber}: la cifratura}
Come un qualsiasi schema di cifratura asimmetrica (dato che formalmente \texttt{Kyber} ricade in questa categoria), le operazioni di \textbf{cifratura} avvengono con la \textbf{chiave pubblica} (ovvero $(A, t)$).

La cifratura in \texttt{Kyber} è composta da \textbf{diversi passi preliminari}:

\begin{enumerate}
    \item Dato un generico messaggio $m$, per prima cosa se ne estrae la \textbf{codifica binaria}: sia $m'$ tale stringa;
    \item Le cifre binarie di $m'$ vengono utilizzate come \textbf{coefficienti di un polinomio}: sia $m_b$ tale polinomio;
    \item $m_b$ viene \textbf{scalato} di un fattore pari a $\nint*{\frac{q}{2}}$ (ovvero il numero intero più vicino a $\frac{q}{2}$) poiché è necessario che i coefficienti dei polinomi devono essere "grandi".
\end{enumerate}

Per l'operazione di cifratura sono necessarie tre \textbf{strutture di supporto}, generate in maniera casuale ad ogni nuova cifratura:

\begin{itemize}
    \item Un vettore $r$ di $k$ componenti detto \textbf{vettore di randomizzazione};
    \item Un vettore $e_1$, anch'esso di $k$ componenti detto \textbf{vettore errore};
    \item Un polinomio $e_2$ detto \textbf{polinomio errore}.
\end{itemize}

A questo punto il messaggio $m_b$ è pronto per essere cifrato.\\ \textbf{Il \textit{ciphertext} in \texttt{Kyber} consiste nella coppia $c = (u, v)$}, con $u$ vettore di $k$ componenti e $v$ polinomio, ottenuti nel seguente modo:

\[ u = A^Tr + e_1 \] \[v = t^Tr + e_2 + m \]

dove $A^T$ rappresenta l'operazione di \textbf{trasposizione} della matrice A e $t^T$ rappresenta l'operazione di trasposizione del vettore $t$.

\subsubsection{\texttt{Kyber}: la decifratura}
Una volta ottenuto $c$, il primo step della decifratura avviene mediante la seguente operazione:

\begin{equation}
    m_n = v - s^Tu
\end{equation}

dove $s^T$ rappresenta la \textbf{trasposizione} della \textbf{chiave privata} $s$. 

Espandendo la (1) si ottiene:

\begin{equation}
    m_n = e^Tr + e_2 + m + s^Te_1
\end{equation}

Il polinomio $m_n$ ottenuto viene detto "rumoroso" poiché di per sé \textbf{non contiene $m_b$}.
Tuttavia, siccome i coefficienti di tutti i polinomi (fatta eccezione per $m_b$, scalato di un fattore $\nint*{\frac{q}{2}}$) sono relativamente \textbf{"piccoli"} è possibile recuperare i coefficienti di quest'ultimo iterando tra i coefficienti di $m_n$ ed operando come segue. 

Sia $a$ un generico coefficiente di $m_n$:

\begin{itemize}
    \item Se $a$ si avvicina di più a $\nint*{\frac{q}{2}}$ che a $q$ o a 0, vuol dire che il coefficiente a lui corrispondente in $m_b$ valeva 1, dunque è necessario arrotondarlo a $\nint*{\frac{q}{2}}$;
    \item Al contrario, se $a$ si avvicina di più a $q$ o a 0 che a $\nint*{\frac{q}{2}}$, vuol dire che il coefficiente a lui corrispondente in $m_b$ valeva 0, dunque è necessario arrotondarlo a $0$;
\end{itemize}

A questo punto, $m_b$ è stato recuperato ed è necessario \textbf{invertire} l'upscaling avvenuto in fase di cifratura mediante una divisione per $\nint*{\frac{q}{2}}$.

Dopo tale operazione è dunque possibile fare riferimento ai coefficienti del risultato per risalire alle cifre di $m'$ e, di conseguenza, di $m$, completando il processo di \textbf{decifratura}.

\newpage
\subsubsection{\texttt{Kyber}: discussione sulla sicurezza}
Gli algoritmi di crittografia post quantistica si contraddistinguono per una certamente maggiore dimensione delle chiavi e naturalmente l'algoritmo \texttt{Kyber} non fa eccezione. Nelle specifiche di tale algoritmo vengono riportate diverse "modalità" di funzionamento, in termini di lunghezza delle chiavi e della \textit{capsula}. La seguente tabella riporta tali valori ed il livello di sicurezza di ciascuna modalità quando confrontato con l'algoritmo \texttt{AES}. Tutte le lunghezze sono espresse in \textbf{bytes}.

\begin{table}[H]
    \centering
    \begin{tabular}{|l|l|l|l|l|}
    \hline
    Modalità  & \texttt{sk} \footnotemark[5] & \texttt{pk} \footnotemark[6] & Lunghezza \textit{capsula} & Livello di sicurezza \\ \hline
    \texttt{Kyber512}  & 1632                     & 800                       & 768                        & \texttt{AES128}              \\ \hline
    \texttt{Kyber768}  & 2400                     & 1184                      & 1088                       & \texttt{AES192}              \\ \hline
    \texttt{Kyber1024} & 3168                     & 1568                      & 1568                       & \texttt{AES256}              \\ \hline
    \end{tabular}
\end{table}

\footnotetext[5]{Lunghezza della \textbf{chiave segreta}}
\footnotetext[6]{Lunghezza della \textbf{chiave pubblica}}

Dal punto di vista della struttura interna, l'unica differenza che intercorre tra le tre versioni dell'algoritmo consiste nella variazione del parametro $k$, introdottto nelle precedenti sezioni e che rappresenta il numero delle componenti dei vettori. In particolare:

\begin{itemize}
    \item Nel caso di \textbf{Kyber512}, $k = 2$;
    \item Nel caso di \textbf{Kyber768}, $k = 3$;
    \item Nel caso di \textbf{Kyber1024}, $k = 4$;
\end{itemize}

Questa caratteristica rende l'implementazione di \texttt{Kyber} estremamente semplice ed efficace poiché tutte e tre le versioni di tale algoritmo possono utilizzare virtualmente lo stesso codice, aumentando notevolmente la \textbf{modularità} dello schema.
\newpage
Gli altri parametri, invece, risultano \textbf{invariati} tra tutte le modalità:

\begin{itemize}
    \item Il \textbf{grado massimo} ($n$) dei polinomi utilizzati è fissato a 256;
    \item Il \textbf{modulo} ($q$) utilizzato per definire l'insieme di riferimento è fissato a 3329.
\end{itemize}

Una discussione sulle \textbf{implementazioni software} per questo algoritmo viene proposta nella sezione successiva di tale documento, che svolge una panoramica sul sistema proposto in questo lavoro.

La scelta della versione di \texttt{Kyber} da utilizzare in questo lavoro è ricaduta su \texttt{Kyber512} per fra fronte al tradeoff necessario tra prestazioni e livello di sicurezza.

\newpage
\section{Descrizione ed implementazione della soluzione proposta}
Dopo una descrizione sullo stato dell'arte del contesto applicativo e delle fondamenta scentifiche e matematiche dell'algoritmo \texttt{Kyber} è ora finalmente possibile svolgere una panoramica sulle modifiche e sulle nuove aggiunte alle piattaforme introdotte e descritte nelle precedenti sezioni.

\subsection{Overview del processo}
Come accennato in fase di introduzione a questo lavoro, l'idea principale consiste nell'integrare l'algoritmo di cifratura post-quantistica \texttt{Kyber} (configurato come \textbf{KEM}, secondo le specifiche proposte al NIST) all'interno delle piattaforme \textbf{ArduPilot} e \textbf{QGroundContol} allo scopo di \textbf{generare} e scambiare una \textbf{chiave simmetrica} per il cifrario \texttt{AES}. Tale cifrario è stato integrato a basso livello nella libreria C \textsc{MAVLink} allo scopo di cifrare il payload (già serializzato e quindi configurato come \textbf{sequenza di bytes}) dei messaggi scambiati tra le due parti che partecipano alla comunicazione. È stato quindi proposto un vero e proprio \textbf{protocollo} per la definizione e la condivisione di suddetta chiave.

\begin{enumerate}
    \item Installazione di un'implementazione di \texttt{Kyber} nell'ambiente di sviluppo;
    \item Definizione del protocollo;
    \item Introduzione di nuovi messaggi \textsc{MAVLink} 2.0;
    \item Integrazione di \texttt{Kyber} all'interno di ArduPilot;
    \item Integrazione di \texttt{Kyber} all'interno di QGroundControl;
    \item Alterazione delle funzioni di \textbf{ArduPilot};
    \item Alterazione delle funzioni di \textbf{QGroundControl};
    \item Alterazione della libreria \textsc{MAVLink}.
\end{enumerate}

Le sezioni successive approfondiscono ciascuno di questi step.

\subsection{Step 1: installazione di un'implementazione di \texttt{Kyber} nell'ambiente di sviluppo}
Sul sito web del progetto \texttt{CRYSTALS} \cite{crystals-software} viene fatta una panoramica delle soluzioni software esistenti che permettono l'utilizzo dello schema di incapsulamento \texttt{Kyber}.

Su GitHub è presente una \textbf{implementazione di riferimento} \cite{kyber-reference} di tale schema nel linguaggio C ottimizzata per processori \textbf{Intel} x86 che sfrutta il set di istruzioni \texttt{AVX2} e che aggiunge il supporto ai vettori a 256 bit, permettendo calcoli in \textbf{virgola mobile} ad alte prestazioni \cite{intel-avx2}.

Esistono tuttavia implementazioni di \texttt{Kyber} integrate in progetti più strutturati come \texttt{PQClean} o \texttt{OpenQuantumSafe}. Quest'ultimo consiste "in un framework per la prototipazione e lo sviluppo di crittografia quantum-resistant" \cite{oqs}.

\subsubsection{\texttt{liboqs}: descrizione ed installazione}
Il progetto di punta di questa organizzazione è però \texttt{liboqs}: una libreria open source che fornisce accesso ad implementazioni di diversi algoritmi post quantistici mediante un'API semplificata. Oltre a \texttt{Kyber}, questa suite include anche altri algoritmi \cite{liboqs-algorithms} \textbf{KEM} candidati nel processo di standardizzazione del NIST (\texttt{Classic McEliece}, \texttt{BIKE}, \texttt{HQC}, \texttt{FrodoKEM} ed \texttt{NTRU-Prime}) e degli schemi di \textbf{firma digitale} (\texttt{CRYSTALS-Dilithium}, \texttt{Falcon} e \texttt{SPHINCS+}). Il codice sorgente di tale libreria è presente su GitHub \cite{liboqs-github} insieme ad una guida per la compilazione e l'installazione del progetto, qui brevemente riportata:

\begin{itemize}
    \item Innanzitutto è necessario clonare la repository del progetto in una directory locale mediante il comando \begin{center}
        \texttt{git clone -b https://github.com/open-quantum-safe/liboqs}
    \end{center}
    e dunque spostarsi nella directory che contiene i sorgenti:
    \begin{center}
        \texttt{cd liboqs/}
    \end{center}
    \item Poiché \texttt{liboqs} usa il sistema di building \textbf{cmake} utilizzato insieme a \texttt{ninja}, è necessario installare alcune dipendenze. Per i sistemi GNU/Linux basati su \textbf{Debian} (come Ubuntu) il comando da eseguire è il seguente:
    \begin{center}
        \texttt{sudo apt install astyle cmake gcc ninja-build libssl-dev python3-pytest python3-pytest-xdist unzip xsltproc doxygen graphviz python3-yaml valgrind}
    \end{center}
    \item È tutto pronto per iniziare il processo di building:
    \begin{center}
        \texttt{mkdir build \&\& cd build \\
        cmake -GNinja .. \\
        ninja}
    \end{center}
    \item Una volta terminato il processo di building, la \textbf{libreria statica} \texttt{liboqs.a} sarà disponibile nella directory \texttt{/build/lib/}. Se, invece, si desidera generare uno \textbf{shared object} è possibile passare il parametro \texttt{-DBUILD\_SHARED\_LIBS=ON} durante l'invocazione di \texttt{cmake}. Il risultato della compilazione, in questo caso, sarà il file \texttt{liboqs.so} nello stesso percorso menzionato in precedenza, oltre che la creazione di una directory \texttt{include/}, che contiene gli \textbf{headers} relativi alla libreria.
    \item Infine, è possibile generare un \textbf{pacchetto} \texttt{.deb} per installare la libreria in maniera \textit{system-wide} mediante un job di \texttt{ninja}:
    \begin{center}
        \texttt{ninja package}
    \end{center}
    e successivamente installando il pacchetto appena generato:
    \begin{center}
        \texttt{sudo dpkg -i <nome\_paccketto>.deb}
    \end{center}
\end{itemize}

A questo punto, \texttt{liboqs} può essere utilizzata all'interno di un generico programma C/C++ utilizzando la direttiva:

\begin{center}
    \texttt{\#include <oqs/oqs.h>}
\end{center}

ed aggiungendo i flag \texttt{-loqs -lcrypto} in fase di building del programma per comunicare al \textbf{linker} il requisito di tale libreria (che possiede \texttt{libcrypto} come dipendenza).

Quest'ultimo aspetto viene qui sottolineato perché necessario negli step successivi descritti in questo capitolo.

Tale libreria, in fase di compilazione, è configurabile in modo da permettere l'abilitazione solo di algoritmi specifici mediante il \textit{flag} \texttt{OQS\_ALGS\_ENABLED}.

In particolare, per ogni schema KEM abilitato nella libreria \texttt{liboqs} offre tre funzioni \cite{liboqsapi} che ricalcano sostanzialmente le procedure \texttt{Gen()}, \texttt{Encaps()} e \texttt{Decaps()} di un generico schema KEM. Per \texttt{Kyber512}, ad esempio:

\begin{itemize}
    \item \texttt{OQS\_KEM\_kyber\_512\_keypair()} permette di generare la coppia di chiavi \texttt{(pk, sk)}: corrisponde al generico \texttt{Gen()};
    \item \texttt{OQS\_KEM\_kyber\_512\_encaps()} permette di generare uno shared secret ed "incapsularlo": corrisponde (naturalmente!) al generico \texttt{Encaps()};
    \item \texttt{OQS\_KEM\_kyber\_512\_encaps()} permette di decapsulare lo shared secret presente nel cifrato: corrisponde al generico \texttt{Decaps()};
\end{itemize}

\newpage
\subsection{Step 2: definizione del protocollo}
Una volta capito \textit{come} ottenere un'implementazione funzionante di \texttt{Kyber} è ora necessario capire \textit{cosa} fare per effettuare correttamente uno scambio di chiavi allo scopo di stabilire una comunicazione cifrata successivamente.

È necessario quindi stabilire \textit{quale} delle due "parti" impegnate nella comunicazione, con riferimento al meccanismo di funzionamento di un KEM descritto in precedenza, deve svolgere le operazioni di \texttt{Gen()}, \texttt{Encaps()} e \texttt{Decaps()}.

In fase di progettazione del nuovo sistema sono state effettuate le seguenti scelte, tenendo anche conto della possibile \footnote{In realtà, molto probabile!} differenza di capacità computazionale tra l'UAV e la GCS (che, si ricorda, è generalmente ospitata su hardware consumer, senza particolari limitazioni di risorse):

\begin{itemize}
    \item L'operazione di \texttt{Gen()} viene effettuata dalla \textbf{GCS}, che \textbf{invia la chiave pubblica} all'UAV;
    \item Una volta ricevuta la chiave pubblica, l'\textbf{UAV} effettua l'operazione di \texttt{Encaps()} (che implica la generazione di una \textbf{chiave segreta}). Successivamente, lo stesso UAV \textbf{invia la capsula} alla GCS;
    \item Alla ricezione della capsula, la \textbf{GCS} effettua l'operazione di \texttt{Decaps()}, \textbf{estrae la chiave segreta}, la \textbf{imposta} ed infine \textbf{invia conferma} all'UAV;
    \item A questo punto, \textbf{le due parti} posseggono la stessa chiave segreta: è finalmente possibile iniziare la \textbf{comunicazione cifrata}.
\end{itemize}

Nello schema presente nella pagina successiva:

\begin{itemize}
    \item \texttt{pk} ed \texttt{sk} rappresentano rispettivamente la \textbf{chiave pubblica} e la \textbf{chiave privata} restituite dalla procedura \texttt{Gen()} dell'algoritmo \texttt{Kyber};
    \item \texttt{capsule} rappresenta la \textbf{capsula} generata dalla procedura \texttt{Encaps()} dell'algoritmo \texttt{Kyber};
    \item \texttt{ss} rappresenta lo \textbf{shared secret}, utilizzata come \textbf{chiave segreta} per la comunicazione cifrata mediante cifrario \texttt{AES}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{images/key_exchange.png}
    \caption{Una rappresentazione grafica del protocollo descritto}
\end{figure}

Si noti che quello mostrato fino ad ora è una descrizione ad alto livello che permette di farsi un'idea di ciò che accade durante la fase di \textbf{scambio della chiave}. Una descrizione a più basso livello dei messaggi effettivamente scambiati tra le due parti della comunicazione viene svolta man mano che vengono presentati i vari step che hanno permetto la creazione del sistema proposto.

\newpage

\subsection{Introduzione di nuovi messaggi \textsc{MAVLink} 2.0}
Nella sezione dedicata al funzionamento della libreria \textsc{MAVLink} è stato sottolineato come fosse possibile \textbf{estenderlo} andando a modificare i file \texttt{XML} che descrivono i messaggi previsti per un certo "dialetto" del protocollo.

Per modellare il funzionamento dello schema di scambio delle chiavi è contestualmente necessario prevedere dei messaggi ad hoc che permettano lo scambio delle informazioni illustrate nella sezione precedente.

Poiché al momento dell'implementazione di questo lavoro \footnote{Inizio Agosto 2023} il progetto \textbf{QGroundControl} utilizzava il dialetto \texttt{ardupilotmega} (prima di effettuare la migrazione al dialetto \texttt{all} a fine Agosto 2023) i nuovi messaggi sono stati aggiunti a tale dialetto e, di conseguenza, inclusi nel file \texttt{ardupilotmega.xml}.

In particolare, sono stati aggiunti \textbf{quattro} messaggi:

\begin{itemize}
    \item \texttt{KEYEXCHANGE};
    \item \texttt{KEYEXCHANGEGCSACK};
    \item \texttt{CAPSULE};
    \item \texttt{CAPSULEACK}.
\end{itemize}

\subsubsection{\texttt{KEYEXCHANGE}}
Questo messaggio \textbf{viene inviato dall'UAV alla GCS} e corrisponde ad una \textit{richiesta} da parte del drone di una \textbf{porzione} della chiave pubblica generata dalla GCS.

La ragione dietro all'adozione di questo approccio è duplice: 

\begin{itemize}
    \item La prima è da ricercarsi in un dettaglio implementativo presente nella piattaforma \textbf{ArduPilot}. In questo software è presente un meccanismo che permette di determinare a tempo di compilazione quale tipo di messaggio deve essere inviato e con quale frequenza. Un meccanismo del genere non è invece presente nativamente all'interno del software \textbf{QGroundControl}, dunque si è scelto di "delegare" tale responsabilità all'UAV;
    \item La seconda deriva da un limite intrinseco del protocollo \textsc{MAVLink} 2.0, che, come già accennato in una sezione precedente, fissa la dimensione del payload di un messaggio a 255 bytes. La dimensione della \textbf{chiave pubblica} per \texttt{Kyber512} è invece fissata ad 800 bytes: è stato quindi necessario \textbf{frammentarla} in diversi \textit{chunks} durante la fase di scambio delle chiavi.
\end{itemize}

La struttura della entry corrispondente al messaggio \texttt{KEYEXCHANGE} all'interno del file \texttt{ardupilotmega.xml} è la seguente:

\begin{minted}[fontsize=\footnotesize]{xml}
    <message id="10000" name="KEYEXCHANGE">
      <description>Key Exchange Mechanism (ArduPilot version).</description>
      <field type="uint8_t" name="seq">Sequence Number.</field>
      <field type="uint16_t" name="chunk_start">Read from.</field>
      <field type="uint16_t" name="chunk_end">Read to.</field>
      <field type="uint8_t[128]" name="iv">IV</field>
    </message>
\end{minted}

In particolare:

\begin{itemize}
    \item Il campo \texttt{seq} consiste in un \textbf{byte} che rappresnta il \textbf{numero di sequenza} del messaggio all'interno del processo di scambio della chiave;
    \item I campi \texttt{chunk\_start} e \texttt{chunk\_end} rappresentano rispettivamente gli \textbf{indici} di inizio e della fine del chunk della chiave pubblica che l'UAV desidera ricevere. Entrambi questi campi sono \textbf{interi a 16 bit};
    \item Il campo \textbf{IV} rappresenta il \textbf{vettore di inizializzazione} utilizzato per la comunicazione cifrata instaurata alla fine del processo di scambio delle chiavi. Consiste in un vettore di 128 bit, come richiesto dalle specifiche del cifrario AES.
\end{itemize}

\subsubsection{\texttt{KEYEXCHANGEGCSACK}}
Questo messaggio rappresenta la "risposta" della \textbf{Ground Control Station} ad un messaggio \texttt{KEYEXCHANGE} da parte del drone. Contiene la porzione di chiave pubblica richiesta da quest'ultimo. La sua struttura è la seguente:


\begin{minted}[fontsize=\footnotesize]{xml}
    <message id="10420" name="KEYEXCHANGEGCSACK">
       <description>Key Exchange Mechanism (GCS version).</description>
       <field type="uint8_t" name="seq_ack">Sequence Number ACK.</field>
       <field type="uint16_t" name="chunk_start">Read from.</field>
       <field type="uint16_t" name="chunk_end">Read to.</field>
       <field type="uint8_t" name="more_data">More data to read.</field>
       <field type="uint8_t[200]" name="data">Data</field>
     </message>
\end{minted}

In particolare:

\begin{itemize}
    \item Il campo \texttt{seq\_ack} rappresenta il \textbf{prossimo} sequence number che la GCS si aspetta. Funge, come suggerisce il nome, da meccanismo di \textbf{Acknowlegement};
    \item I campi \texttt{chunk\_start} e \texttt{chunk\_end} rappresentano rispettivamente gli \textbf{indici} di inizio e della fine del chunk della chiave pubblica che l'UAV desidera ricevere. Entrambi questi campi sono \textbf{interi a 16 bit}. Riflettono quelli inviati nel messaggio precedente;
    \item Il campo \texttt{more\_data} rappresenta un flag che permette, quando è impostato a 0, di avvisare l'UAV che lo scambio della chiave pubblica è terminato.
\end{itemize}

\subsubsection{\texttt{CAPSULE} e \texttt{CAPSULEACK}}
In maniera speculare a quanto avviene durante lo scambio della chiave pubblica, il messaggio \texttt{CAPSULE} rappresenta l'invio, da parte dell'UAV di una porzione della \textbf{capsula}, generata dopo aver ricevuto completamente la chiave pubblica ed aver invocato \texttt{Encaps()}.

La struttura di \texttt{CAPSULE} è la seguente:

\begin{minted}[fontsize=\footnotesize]{xml}
    <message id="10421" name="CAPSULE">
       <description>KEM Capsule.</description>
       <field type="uint8_t" name="seq">Sequence Number.</field>
       <field type="uint16_t" name="chunk_start">Read from.</field>
       <field type="uint16_t" name="chunk_end">Read to.</field>
       <field type="uint8_t" name="more_data">More data to read.</field>
       <field type="uint8_t[192]" name="data">Data</field>
     </message>
\end{minted}

In particolare:

\begin{itemize}
    \item Il campo \texttt{seq} consiste in un \textbf{byte} che rappresnta il \textbf{numero di sequenza} del messaggio all'interno del processo di scambio della capsula;
    \item I campi \texttt{chunk\_start} e \texttt{chunk\_end} rappresentano rispettivamente gli \textbf{indici} di inizio e della fine del chunk della capsula che l'UAV desidera inviare alla GCS. Entrambi questi campi sono \textbf{interi a 16 bit};
    \item Il campo \texttt{more\_data} rappresenta un flag che permette, quando è impostato a 0, di avvisare l'UAV che lo scambio della capsula è terminato e la GCS può di conseguenza invocare \texttt{Decaps()}.
\end{itemize}

Il messaggio \texttt{CAPSULEACK} testimonia semplicmente l'avvenuta ricezione della GCS di un messaggio \texttt{CAPSULE} ed in particolare contiene \textbf{il prossimo numero di sequenza atteso}.

Ecco la struttura di un messaggio \texttt{CAPSULEACK}:

\begin{minted}[fontsize=\footnotesize]{xml}
    <message id="10422" name="CAPSULEACK">
       <description>KEM Capsule ACK.</description>
       <field type="uint8_t" name="ack">Next Sequence Number.</field>
     </message>
\end{minted}

\newpage
\subsection{Step 3: Integrazione di \texttt{Kyber} all'interno di ArduPilot}
Come accennato in fase di presentazione di tale piattaforma software, \textbf{ArduPilot} utilizza il sistema di building \texttt{waf}. Di conseguenza, l'introduzione di nuove librerie all'interno di un progetto che fa uso di questo sistema di building deve naturalmente avvenire nei suoi file di configurazione. Per rendere quanto più semplice possibile il processo di integrazione e di linking di \texttt{liboqs} (come già descritto nello \textbf{Step 1}), tale libreria è stata installata in maniera system-wide sulla macchina su cui è stato svolto il lavoro allo scopo di minimizzare le modifiche a cui sottoporre il progetto. Di conseguenza, l'unico accorgimento da adottare consiste nell'aggiungere i flag \texttt{-loqs -lcrypto} in fase di linking. Tale operazione, di norma, si effettua andando a modificare la variabile d'ambiente \texttt{LDFLAGS}.

Nel caso di \texttt{waf}, invece, è necessario andare a modificare il file \texttt{wscript} (uno script Python), presente nella root della repository del progetto \textbf{ArduPilot}.

In particolare, è necessario considerare la funzione \texttt{build(bld)}, il cui parametro espone l'oggetto \texttt{env}, che modella \textbf{una copia} delle \textbf{variabili d'ambiente} da consultare in fase di compilazione e di linking, tra cui \texttt{CXXFLAGS} e (convenientemente!) \texttt{LDFLAGS}.

Ciascuna di queste variabili d'ambiente è resa come una \textbf{lista di valori}, che può essere modificata ed \textbf{estesa}. L'aggiunta dei due flag ad \texttt{LDFLAGS} si effettua quindi come segue:

\begin{minted}{python}
    def build(bld):
        bld.env.LDFLAGS += ['-loqs', '-lcrypto']
\end{minted}

A questo punto è possibile ricompilare \textbf{ArduCopter} mediante il comando:

\begin{center}
    \texttt{./waf copter -v}
\end{center}

utilizzando lo switch \texttt{-v} per abilitare la modalità \textit{verbose} e di conseguenza accertarsi che suddetti flag siano presenti nella stringa del linker mostrata durante l'ultima fase del processo di building.

\newpage
\printbibliography[title={Riferimenti bibliografici e risorse consultate}]
\end{document} 